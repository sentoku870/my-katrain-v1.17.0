import copy
import math
import os
import re
import threading
from datetime import datetime
from typing import Dict, List, Optional, Union

from kivy.clock import Clock

from . import eval_metrics
from .eval_metrics import (
    EvalSnapshot,
    GameSummaryData,
    MistakeCategory,
    MistakeStreak,
    MoveEval,
    PhaseMistakeStats,
    PositionDifficulty,
    QuizChoice,
    QuizItem,
    QuizQuestion,
    SummaryStats,
    aggregate_phase_mistake_stats,
    classify_mistake,
    detect_mistake_streaks,
    get_canonical_loss_from_move,
    get_practice_priorities_from_stats,
    quiz_items_from_snapshot,
    quiz_points_lost_from_candidate,
    snapshot_from_game,
)
from katrain.core.constants import (
    OUTPUT_DEBUG,
    OUTPUT_EXTRA_DEBUG,
    OUTPUT_INFO,
    PLAYER_AI,
    PLAYER_HUMAN,
    PROGRAM_NAME,
    SGF_INTERNAL_COMMENTS_MARKER,
    STATUS_ANALYSIS,
    STATUS_ERROR,
    STATUS_INFO,
    STATUS_TEACHING,
    PRIORITY_GAME_ANALYSIS,
    PRIORITY_EXTRA_ANALYSIS,
    PRIORITY_SWEEP,
    PRIORITY_ALTERNATIVES,
    PRIORITY_EQUALIZE,
    PRIORITY_DEFAULT,
)


class KarteGenerationError(Exception):
    """Exception raised when karte generation fails.

    Attributes:
        game_id: Identifier of the game being processed
        focus_player: Player filter if any ("B", "W", or None)
        context: Additional context about where the error occurred
        original_error: The underlying exception that caused this error
    """

    def __init__(
        self,
        message: str,
        game_id: str = "",
        focus_player: Optional[str] = None,
        context: str = "",
        original_error: Optional[Exception] = None,
    ):
        super().__init__(message)
        self.game_id = game_id
        self.focus_player = focus_player
        self.context = context
        self.original_error = original_error

    def __str__(self) -> str:
        parts = [super().__str__()]
        if self.game_id:
            parts.append(f"game_id={self.game_id}")
        if self.focus_player:
            parts.append(f"focus_player={self.focus_player}")
        if self.context:
            parts.append(f"context={self.context}")
        return " | ".join(parts)


from katrain.core.engine import KataGoEngine
from katrain.core.game_node import GameNode
from katrain.core.lang import i18n, rank_label
from katrain.core.sgf_parser import SGF, Move
from katrain.core.utils import var_to_grid, weighted_selection_without_replacement


class IllegalMoveException(Exception):
    pass


class KaTrainSGF(SGF):
    _NODE_CLASS = GameNode


class BaseGame:
    """Represents a game of go, including an implementation of capture rules."""

    DEFAULT_PROPERTIES = {"GM": 1, "FF": 4}

    def __init__(
        self,
        katrain,
        move_tree: GameNode = None,
        game_properties: Optional[Dict] = None,
        sgf_filename=None,
        bypass_config=False,  # TODO: refactor?
    ):
        self.katrain = katrain
        self._lock = threading.Lock()
        self.game_id = datetime.strftime(datetime.now(), "%Y-%m-%d %H %M %S")
        self.sgf_filename = sgf_filename

        self.insert_mode = False
        self.external_game = False  # not generated by katrain at some point

        if move_tree:
            self.root = move_tree
            self.external_game = PROGRAM_NAME not in self.root.get_property("AP", "")
            handicap = int(self.root.handicap)
            num_starting_moves_black = 0
            node = self.root
            while node.children:
                node = node.children[0]
                if node.player == "B":
                    num_starting_moves_black += 1
                else:
                    break

            if (
                handicap >= 2
                and not self.root.placements
                and not (num_starting_moves_black == handicap)
                and not (self.root.children and self.root.children[0].placements)
            ):  # not really according to sgf, and not sure if still needed, last clause for fox
                self.root.place_handicap_stones(handicap)
        else:
            default_properties = {**Game.DEFAULT_PROPERTIES, "DT": self.game_id}
            if not bypass_config:
                default_properties.update(
                    {
                        "SZ": katrain.config("game/size"),
                        "KM": katrain.config("game/komi"),
                        "RU": katrain.config("game/rules"),
                    }
                )
            self.root = GameNode(
                properties={
                    **default_properties,
                    **(game_properties or {}),
                }
            )
            handicap = katrain.config("game/handicap")
            if not bypass_config and handicap:
                self.root.place_handicap_stones(handicap)

        if not self.root.get_property("RU"):  # if rules missing in sgf, inherit current
            self.root.set_property("RU", katrain.config("game/rules"))

        self.set_current_node(self.root)
        self.main_time_used = 0

        # restore shortcuts
        shortcut_id_to_node = {node.get_property("KTSID", None): node for node in self.root.nodes_in_tree}
        for node in self.root.nodes_in_tree:
            shortcut_id = node.get_property("KTSF", None)
            if shortcut_id and shortcut_id in shortcut_id_to_node:
                shortcut_id_to_node[shortcut_id].add_shortcut(node)

    # -- move tree functions --
    def _init_state(self):
        board_size_x, board_size_y = self.board_size
        self.board = [
            [-1 for _x in range(board_size_x)] for _y in range(board_size_y)
        ]  # type: List[List[int]]  #  board pos -> chain id
        self.chains = []  # type: List[List[Move]]  #   chain id -> chain
        self.prisoners = []  # type: List[Move]
        self.last_capture = []  # type: List[Move]

    def _calculate_groups(self):
        with self._lock:
            self._init_state()
            try:
                for node in self.current_node.nodes_from_root:
                    for m in node.move_with_placements:
                        self._validate_move_and_update_chains(
                            m, True
                        )  # ignore ko since we didn't know if it was forced
                    if node.clear_placements:  # handle AE by playing all moves left from empty board
                        clear_coords = {c.coords for c in node.clear_placements}
                        stones = [m for c in self.chains for m in c if m.coords not in clear_coords]
                        self._init_state()
                        for m in stones:
                            self._validate_move_and_update_chains(m, True)
            except IllegalMoveException as e:
                raise Exception(f"Unexpected illegal move ({str(e)})")

    def _validate_move_and_update_chains(self, move: Move, ignore_ko: bool):
        board_size_x, board_size_y = self.board_size

        def neighbours(moves):
            return {
                self.board[m.coords[1] + dy][m.coords[0] + dx]
                for m in moves
                for dy, dx in [(-1, 0), (1, 0), (0, -1), (0, 1)]
                if 0 <= m.coords[0] + dx < board_size_x and 0 <= m.coords[1] + dy < board_size_y
            }

        ko_or_snapback = len(self.last_capture) == 1 and self.last_capture[0] == move
        self.last_capture = []

        if move.is_pass:
            return

        if self.board[move.coords[1]][move.coords[0]] != -1:
            raise IllegalMoveException("Space occupied")

        # merge chains connected by this move, or create a new one
        nb_chains = list({c for c in neighbours([move]) if c >= 0 and self.chains[c][0].player == move.player})
        if nb_chains:
            this_chain = nb_chains[0]
            self.board = [[nb_chains[0] if sq in nb_chains else sq for sq in line] for line in self.board]
            for oc in nb_chains[1:]:
                self.chains[nb_chains[0]] += self.chains[oc]
                self.chains[oc] = []
            self.chains[nb_chains[0]].append(move)
        else:
            this_chain = len(self.chains)
            self.chains.append([move])
        self.board[move.coords[1]][move.coords[0]] = this_chain

        # check captures
        opp_nb_chains = {c for c in neighbours([move]) if c >= 0 and self.chains[c][0].player != move.player}
        for c in opp_nb_chains:
            if -1 not in neighbours(self.chains[c]):  # no liberties
                self.last_capture += self.chains[c]
                for om in self.chains[c]:
                    self.board[om.coords[1]][om.coords[0]] = -1
                self.chains[c] = []
        if ko_or_snapback and len(self.last_capture) == 1 and not ignore_ko:
            raise IllegalMoveException("Ko")
        self.prisoners += self.last_capture

        # suicide: check rules and throw exception if needed
        if -1 not in neighbours(self.chains[this_chain]):
            rules = self.rules
            if len(self.chains[this_chain]) == 1:  # even in new zealand rules, single stone suicide is not allowed
                raise IllegalMoveException("Single stone suicide")
            elif (isinstance(rules, str) and rules in ["tromp-taylor", "new zealand"]) or (
                isinstance(rules, dict) and rules.get("suicide", False)
            ):
                self.last_capture += self.chains[this_chain]
                for om in self.chains[this_chain]:
                    self.board[om.coords[1]][om.coords[0]] = -1
                self.chains[this_chain] = []
                self.prisoners += self.last_capture
            else:  # suicide not allowed by rules
                raise IllegalMoveException("Suicide")

    # Play a Move from the current position, raise IllegalMoveException if invalid.
    def play(self, move: Move, ignore_ko: bool = False):
        board_size_x, board_size_y = self.board_size
        if not move.is_pass and not (0 <= move.coords[0] < board_size_x and 0 <= move.coords[1] < board_size_y):
            raise IllegalMoveException(f"Move {move} outside of board coordinates")
        try:
            self._validate_move_and_update_chains(move, ignore_ko)
        except IllegalMoveException:
            self._calculate_groups()
            raise
        with self._lock:
            played_node = self.current_node.play(move)
            self.current_node = played_node
        return played_node

    # Insert a list of moves from root, often just adding one.
    def sync_branch(self, moves: List[Move]):
        node = self.root
        with self._lock:
            for move in moves:
                node = node.play(move)
        return node

    def set_current_node(self, node):
        self.current_node = node
        self._calculate_groups()

    def undo(self, n_times=1, stop_on_mistake=None):
        break_on_branch = False
        cn = self.current_node  # avoid race conditions
        break_on_main_branch = False
        last_branching_node = cn
        if n_times == "branch":
            n_times = 9999
            break_on_branch = True
        elif n_times == "main-branch":
            n_times = 9999
            break_on_main_branch = True
        for move in range(n_times):
            if (
                stop_on_mistake is not None
                and cn.points_lost is not None
                and cn.points_lost >= stop_on_mistake
                and self.katrain.players_info[cn.player].player_type != PLAYER_AI
            ):
                self.set_current_node(cn.parent)
                return
            previous_cn = cn
            if cn.shortcut_from:
                cn = cn.shortcut_from
            elif not cn.is_root:
                cn = cn.parent
            else:
                break  # root
            if break_on_branch and len(cn.children) > 1:
                break
            elif break_on_main_branch and cn.ordered_children[0] != previous_cn:  # implies > 1 child
                last_branching_node = cn
        if break_on_main_branch:
            cn = last_branching_node
        if cn is not self.current_node:
            self.set_current_node(cn)

    def redo(self, n_times=1, stop_on_mistake=None):
        cn = self.current_node  # avoid race conditions
        for move in range(n_times):
            if cn.children:
                child = cn.ordered_children[0]
                shortcut_to = [m for m, v in cn.shortcuts_to if child == v]  # are we about to go to a shortcut node?
                if shortcut_to:
                    child = shortcut_to[0]
                cn = child
            if (
                move > 0
                and stop_on_mistake is not None
                and cn.points_lost is not None
                and cn.points_lost >= stop_on_mistake
                and self.katrain.players_info[cn.player].player_type != PLAYER_AI
            ):
                self.set_current_node(cn.parent)
                return
        if stop_on_mistake is None:
            self.set_current_node(cn)

    @property
    def komi(self):
        return self.root.komi

    @property
    def board_size(self):
        return self.root.board_size

    @property
    def stones(self):
        with self._lock:
            return sum(self.chains, [])

    @property
    def end_result(self):
        if self.current_node.end_state:
            return self.current_node.end_state
        if self.current_node.parent and self.current_node.is_pass and self.current_node.parent.is_pass:
            return self.manual_score or i18n._("board-game-end")

    @property
    def prisoner_count(
        self,
    ) -> Dict:  # returns prisoners that are of a certain colour as {B: black stones captures, W: white stones captures}
        return {player: sum([m.player == player for m in self.prisoners]) for player in Move.PLAYERS}

    @property
    def rules(self):
        return KataGoEngine.get_rules(self.root.ruleset)

    @property
    def manual_score(self):
        rules = self.rules
        if (
            not self.current_node.ownership
            or str(rules).lower() not in ["jp", "japanese"]
            or not self.current_node.parent
            or not self.current_node.parent.ownership
        ):
            if not self.current_node.score:
                return None
            return self.current_node.format_score(round(2 * self.current_node.score) / 2) + "?"
        board_size_x, board_size_y = self.board_size
        mean_ownership = [(c + p) / 2 for c, p in zip(self.current_node.ownership, self.current_node.parent.ownership)]
        ownership_grid = var_to_grid(mean_ownership, (board_size_x, board_size_y))
        stones = {m.coords: m.player for m in self.stones}
        lo_threshold = 0.15
        hi_threshold = 0.85
        max_unknown = 10
        max_dame = 4 * (board_size_x + board_size_y)

        def japanese_score_square(square, owner):
            player = stones.get(square, None)
            if (
                (player == "B" and owner > hi_threshold)
                or (player == "W" and owner < -hi_threshold)
                or abs(owner) < lo_threshold
            ):
                return 0  # dame or own stones
            if player is None and abs(owner) >= hi_threshold:
                return round(owner)  # surrounded empty intersection
            if (player == "B" and owner < -hi_threshold) or (player == "W" and owner > hi_threshold):
                return 2 * round(owner)  # captured stone
            return math.nan  # unknown!

        scored_squares = [
            japanese_score_square((x, y), ownership_grid[y][x])
            for y in range(board_size_y)
            for x in range(board_size_x)
        ]
        num_sq = {t: sum([s == t for s in scored_squares]) for t in [-2, -1, 0, 1, 2]}
        num_unkn = sum(math.isnan(s) for s in scored_squares)
        prisoners = self.prisoner_count
        score = sum([t * n for t, n in num_sq.items()]) + prisoners["W"] - prisoners["B"] - self.komi
        self.katrain.log(
            f"Manual Scoring: {num_sq} score by square with {num_unkn} unknown, {prisoners} captures, and {self.komi} komi -> score = {score}",
            OUTPUT_DEBUG,
        )
        if num_unkn > max_unknown or (num_sq[0] - len(stones)) > max_dame:
            return None
        return self.current_node.format_score(score)

    def __repr__(self):
        return (
            "\n".join("".join(self.chains[c][0].player if c >= 0 else "-" for c in line) for line in self.board)
            + f"\ncaptures: {self.prisoner_count}"
        )

    def update_root_properties(self):
        def player_name(player_info):
            if player_info.name and player_info.player_type == PLAYER_HUMAN:
                return player_info.name
            else:
                return f"{i18n._(player_info.player_type)} ({i18n._(player_info.player_subtype)}){SGF_INTERNAL_COMMENTS_MARKER}"

        root_properties = self.root.properties
        x_properties = {}
        for bw in "BW":
            if not self.external_game:
                x_properties["P" + bw] = player_name(self.katrain.players_info[bw])
                player_info = self.katrain.players_info[bw]
                if player_info.player_type == PLAYER_AI:
                    x_properties[bw + "R"] = rank_label(player_info.calculated_rank)
        if "+" in str(self.end_result):
            x_properties["RE"] = self.end_result
        self.root.properties = {**root_properties, **{k: [v] for k, v in x_properties.items()}}

    def generate_filename(self):
        self.update_root_properties()
        player_names = {
            bw: re.sub(r"[\u200b\u3164'<>:\"/\\|?*]", "", self.root.get_property("P" + bw, bw)) for bw in "BW"
        }
        base_game_name = f"{PROGRAM_NAME}_{player_names['B']} vs {player_names['W']}"
        return f"{base_game_name} {self.game_id}.sgf"

    def write_sgf(self, filename: str, trainer_config: Optional[Dict] = None):
        if trainer_config is None:
            trainer_config = self.katrain.config("trainer", {})
        save_feedback = trainer_config.get("save_feedback", False)
        eval_thresholds = trainer_config["eval_thresholds"]
        save_analysis = trainer_config.get("save_analysis", False)
        save_marks = trainer_config.get("save_marks", False)
        self.update_root_properties()
        show_dots_for = {
            bw: trainer_config.get("eval_show_ai", True) or self.katrain.players_info[bw].human for bw in "BW"
        }
        sgf = self.root.sgf(
            save_comments_player=show_dots_for,
            save_comments_class=save_feedback,
            eval_thresholds=eval_thresholds,
            save_analysis=save_analysis,
            save_marks=save_marks,
        )
        self.sgf_filename = filename
        os.makedirs(os.path.dirname(filename), exist_ok=True)
        with open(filename, "w", encoding="utf-8") as f:
            f.write(sgf)
        return i18n._("sgf written").format(file_name=filename)


class Game(BaseGame):
    """Extensions related to analysis etc."""

    def __init__(
        self,
        katrain,
        engine: Union[Dict, KataGoEngine],
        move_tree: GameNode = None,
        analyze_fast=False,
        game_properties: Optional[Dict] = None,
        sgf_filename=None,
    ):
        super().__init__(
            katrain=katrain, move_tree=move_tree, game_properties=game_properties, sgf_filename=sgf_filename
        )
        if not isinstance(engine, Dict):
            engine = {"B": engine, "W": engine}
        self.engines = engine

        self.insert_mode = False
        self.insert_after = None
        self.region_of_interest = None

        # Stop any existing pondering before starting full-game analysis
        katrain.pondering = False
        for e in set(self.engines.values()):
            e.stop_pondering()

        threading.Thread(
            target=lambda: self.analyze_all_nodes(analyze_fast=analyze_fast, even_if_present=True),
            daemon=True,
        ).start()  # return faster, but bypass Kivy Clock

    def analyze_all_nodes(
        self,
        priority=PRIORITY_GAME_ANALYSIS,
        analyze_fast: bool = False,
        even_if_present: bool = True,
    ) -> None:
        for node in self.root.nodes_in_tree:
            # forced, or not present, or something went wrong in loading
            if even_if_present or not node.analysis_from_sgf or not node.load_analysis():
                node.clear_analysis()
                node.analyze(
                    self.engines[node.next_player],
                    priority=priority,
                    analyze_fast=analyze_fast,
                )


    def build_eval_snapshot(self) -> EvalSnapshot:
        """
        現在の Game（メイン分岐）から EvalSnapshot を生成するヘルパー。

        Phase 2 以降で UI や教育機能から共通で呼び出す入口として使う。
        """
        return snapshot_from_game(self)

    def get_quiz_items(
        self,
        *,
        loss_threshold: float = eval_metrics.DEFAULT_QUIZ_LOSS_THRESHOLD,
        limit: int = eval_metrics.DEFAULT_QUIZ_ITEM_LIMIT,
    ) -> List[QuizItem]:
        """
        現在の対局（メイン分岐）からクイズ用の大きなミス一覧を返す。

        - 既存の EvalSnapshot と quiz_items_from_snapshot をまとめた入口。
        - 解析済みの情報だけを使用し、新たな分析は開始しない。
        """
        snapshot = self.build_eval_snapshot()
        if not snapshot.moves:
            return []

        return quiz_items_from_snapshot(
            snapshot, loss_threshold=loss_threshold, limit=limit
        )

    def build_quiz_questions(
        self,
        quiz_items: List[QuizItem],
        *,
        max_choices: int = 3,
    ) -> List[QuizQuestion]:
        """
        Convert quiz items into quiz questions using existing analysis only.

        - Uses candidate_moves from the position before each mistake.
        - Does not trigger any new engine analysis.
        """
        questions: List[QuizQuestion] = []
        for item in quiz_items:
            node_before = self.get_main_branch_node_before_move(item.move_number)
            choices: List[QuizChoice] = []
            best_move: Optional[str] = None
            if node_before is not None and getattr(node_before, "analysis_exists", False):
                candidate_moves = node_before.candidate_moves
                if candidate_moves:
                    best_move = candidate_moves[0].get("move")
                    analysis = getattr(node_before, "analysis", None) or {}
                    root_score = None
                    if isinstance(analysis, dict):
                        root_score = (analysis.get("root") or {}).get("scoreLead")
                    for mv in candidate_moves[:max_choices]:
                        move_id = mv.get("move", "") or ""
                        loss_val = quiz_points_lost_from_candidate(
                            mv,
                            root_score=root_score,
                            next_player=getattr(node_before, "next_player", None),
                        )
                        choices.append(
                            QuizChoice(move=move_id, points_lost=loss_val)
                        )
            questions.append(
                QuizQuestion(
                    item=item,
                    choices=choices,
                    best_move=best_move,
                    node_before_move=node_before,
                )
            )
        return questions

    def log_mistake_summary_for_debug(self) -> None:
        """
        対局全体のミス分類サマリをコンソールに出力するデバッグ用ユーティリティ。
        - Phase3 のしきい値設定・挙動確認に使用する。
        """
        snapshot = self.build_eval_snapshot()

        counts: Dict[MistakeCategory, int] = {}
        for m in snapshot.moves:
            # None の場合は GOOD 扱いに寄せる
            cat = m.mistake_category or MistakeCategory.GOOD
            counts[cat] = counts.get(cat, 0) + 1

        total_moves = len(snapshot.moves)

        print("=== Mistake summary (debug) ===")
        print(f"Total moves: {total_moves}")
        # カテゴリ順に固定したい場合は MistakeCategory の順で回す
        for cat in MistakeCategory:
            n = counts.get(cat, 0)
            label = cat.value  # "BLUNDER" 等
            print(f"{label:10s}: {n:3d}")

    # ------------------------------------------------------------------
    # 重要局面レポート / YoseAnalyzer 連携用のヘルパー
    # ------------------------------------------------------------------

    def _find_node_by_move_number(self, move_number: int) -> Optional[GameNode]:
        """メインブランチの手数でノードを検索

        Args:
            move_number: 手数（1-indexed）

        Returns:
            Optional[GameNode]: 見つかったノード、または None
        """
        for node in eval_metrics.iter_main_branch_nodes(self):
            node_move_no = len(node.nodes_from_root) - 1
            if node_move_no == move_number:
                return node
        return None

    def get_important_move_evals(
        self,
        *,
        level: str = eval_metrics.DEFAULT_IMPORTANT_MOVE_LEVEL,
        compute_reason_tags: bool = True,
    ) -> List[MoveEval]:
        """
        現在の対局（メイン分岐）について、
        重要度スコアの大きい手 (= 重要局面候補) を MoveEval のリストとして返す。

        - EvalSnapshot + pick_important_moves をまとめた入口。
        - 今後 YoseAnalyzer からもここを呼ぶ想定。
        """
        snapshot = self.build_eval_snapshot()

        # 手が 1 手もない（起動直後の空局面など）は空リスト
        if not snapshot.moves:
            return []

        important_moves = eval_metrics.pick_important_moves(
            snapshot,
            level=level,
            recompute=True,
        )

        # Phase 5: 重要局面のみ理由タグを計算
        if compute_reason_tags:
            from katrain.core import board_analysis

            unknown_count = 0
            for move_eval in important_moves:
                try:
                    # 対応するノードを検索
                    node = self._find_node_by_move_number(move_eval.move_number)
                    if node is None:
                        move_eval.reason_tags = ["unknown"]
                        unknown_count += 1
                        continue

                    # このノードで盤面を分析
                    board_state = board_analysis.analyze_board_at_node(self, node)

                    # 候補手を取得
                    candidates = node.candidate_moves if hasattr(node, 'candidate_moves') else []

                    # タグを計算（Phase 17: skill_preset を渡す）
                    move_eval.reason_tags = board_analysis.get_reason_tags_for_move(
                        board_state, move_eval, node, candidates, skill_preset=level
                    )

                    # タグが空の場合は "unknown" を設定
                    if not move_eval.reason_tags:
                        move_eval.reason_tags = ["unknown"]
                        unknown_count += 1
                except Exception as e:
                    # 失敗時は優雅に処理: 分析失敗時は "unknown" を設定
                    self.katrain.log(
                        f"Failed to compute reason tags for move #{move_eval.move_number}: {e}",
                        OUTPUT_DEBUG
                    )
                    move_eval.reason_tags = ["unknown"]
                    unknown_count += 1

            # unknown_count をログに出力（カバレッジ確認用）
            if unknown_count > 0 and important_moves:
                self.katrain.log(
                    f"[ReasonTags] {unknown_count}/{len(important_moves)} moves have unknown reason tags",
                    OUTPUT_DEBUG
                )

        return important_moves

    def build_important_moves_report(
        self,
        *,
        level: str = eval_metrics.DEFAULT_IMPORTANT_MOVE_LEVEL,
        max_lines: Optional[int] = None,
    ) -> str:
        """
        現在の対局（メイン分岐）について、
        「重要度スコアが大きい手」をテキストレポートとして返す。

        - 手数 / 手番 / 着手 / 損失(目) / ミス分類 / 難易度 / 形勢差Δ / 勝率Δ
        - eval_metrics.pick_important_moves の結果に基づく

        Args:
            level:
                重要局面検出のレベル。
                - "easy"   : ゆるめに拾う
                - "normal" : 標準
                - "strict" : より厳しめに大きな局面だけ
            max_lines:
                レポートの最大行数（None の場合は全件）
        """
        important_moves = self.get_important_move_evals(level=level)

        if not important_moves:
            settings = eval_metrics.IMPORTANT_MOVE_SETTINGS_BY_LEVEL.get(
                level,
                eval_metrics.IMPORTANT_MOVE_SETTINGS_BY_LEVEL[eval_metrics.DEFAULT_IMPORTANT_MOVE_LEVEL],
            )
            return (
                f"重要局面候補 (level={level}, "
                f"threshold={settings.importance_threshold}, "
                f"max_moves={settings.max_moves}) は見つかりませんでした。"
            )

        # 必要に応じて行数を制限
        if max_lines is not None and max_lines > 0:
            important_moves = important_moves[:max_lines]

        def fmt_score(v: Optional[float]) -> str:
            if v is None:
                return "-"
            return f"{v:+.1f}"

        def fmt_winrate(v: Optional[float]) -> str:
            if v is None:
                return "-"
            return f"{v:+.1f}%"

        def fmt_mistake(mc: Optional[MistakeCategory]) -> str:
            if mc is None:
                return "-"
            mapping = {
                MistakeCategory.GOOD: "良",
                MistakeCategory.INACCURACY: "軽",
                MistakeCategory.MISTAKE: "悪",
                MistakeCategory.BLUNDER: "大悪",
            }
            return mapping.get(mc, "-")

        def fmt_difficulty(difficulty) -> str:
            """
            PositionDifficulty を短い日本語ラベルに変換する。

            EASY      -> "易"
            NORMAL    -> "普"
            HARD      -> "難"
            ONLY_MOVE -> "一手"
            UNKNOWN   -> "-"
            """
            if difficulty is None:
                return "-"
            # Enum を想定し、.value から判定する
            value = getattr(difficulty, "value", None)
            mapping = {
                "easy": "易",
                "normal": "普",
                "hard": "難",
                "only": "一手",
                "unknown": "-",
            }
            if value is None:
                return "-"
            return mapping.get(value, "-")

        # 見出し行
        settings = eval_metrics.IMPORTANT_MOVE_SETTINGS_BY_LEVEL.get(
            level,
            eval_metrics.IMPORTANT_MOVE_SETTINGS_BY_LEVEL[eval_metrics.DEFAULT_IMPORTANT_MOVE_LEVEL],
        )
        lines: List[str] = []
        lines.append(
            f"重要局面候補 (level={level}, "
            f"threshold={settings.importance_threshold}, "
            f"max_moves={settings.max_moves})"
        )
        lines.append("")  # 空行

        # ヘッダ
        # 手数 / 手番 / 着手 / 損失(目) / ミス分類 / 難易度 / 形勢差Δ / 勝率Δ
        lines.append("手数  手番  着手   損失(目)  ミス   難度   形勢差Δ  勝率Δ")
        lines.append("-" * 52)

        # 各手を 1 行に整形
        for m in important_moves:
            if not isinstance(m, MoveEval):
                continue

            move_no = m.move_number
            player = m.player or "-"
            gtp = m.gtp or "-"

            pl = fmt_score(m.points_lost)
            ds = fmt_score(m.delta_score)
            dw = fmt_winrate(m.delta_winrate)
            mc = fmt_mistake(m.mistake_category)
            df = fmt_difficulty(getattr(m, "position_difficulty", None))

            lines.append(
                f"{move_no:>3}   {player:>1}   {gtp:>4}   {pl:>7}  {mc:>4}  {df:>4}  {ds:>7}  {dw:>7}"
            )

        return "\n".join(lines)

    def build_karte_report(
        self,
        level: str = eval_metrics.DEFAULT_IMPORTANT_MOVE_LEVEL,
        player_filter: Optional[str] = None,
        raise_on_error: bool = False,
    ) -> str:
        """Build a compact, markdown-friendly report for the current game.

        Args:
            level: Important move level setting
            player_filter: Filter by player ("B", "W", or None for both)
                          Can also be a username string to match against player names
            raise_on_error: If True, raise KarteGenerationError on failure.
                           If False (default), return error markdown instead.

        Returns:
            Markdown-formatted karte report.
            On error with raise_on_error=False, returns a report with ERROR section.

        Raises:
            KarteGenerationError: If raise_on_error=True and generation fails.
        """
        game_id = self.game_id or self.sgf_filename or "unknown"

        try:
            return self._build_karte_report_impl(level, player_filter)
        except Exception as e:
            error_msg = f"Failed to generate karte: {type(e).__name__}: {e}"
            if self.katrain:
                self.katrain.log(error_msg, OUTPUT_DEBUG)

            if raise_on_error:
                raise KarteGenerationError(
                    message=error_msg,
                    game_id=game_id,
                    focus_player=player_filter,
                    context="build_karte_report",
                    original_error=e,
                ) from e

            # Return error markdown instead of crashing
            return self._build_error_karte(game_id, player_filter, error_msg)

    def _build_error_karte(
        self,
        game_id: str,
        player_filter: Optional[str],
        error_msg: str,
    ) -> str:
        """Build a minimal karte with ERROR section when generation fails."""
        sections = [
            "# Karte (ERROR)",
            "",
            "## Meta",
            f"- Game: {game_id}",
            f"- Player Filter: {player_filter or 'both'}",
            "",
            "## ERROR",
            "",
            "Karte generation failed with the following error:",
            "",
            f"```",
            error_msg,
            f"```",
            "",
            "Please check:",
            "- The game has been analyzed (KT property present)",
            "- The SGF file is not corrupted",
            "- KataGo engine is running correctly",
            "",
        ]
        return "\n".join(sections)

    def _build_karte_report_impl(
        self,
        level: str,
        player_filter: Optional[str],
    ) -> str:
        """Internal implementation of build_karte_report."""
        snapshot = self.build_eval_snapshot()
        thresholds = self.katrain.config("trainer/eval_thresholds") if self.katrain else []
        settings = eval_metrics.IMPORTANT_MOVE_SETTINGS_BY_LEVEL.get(
            level, eval_metrics.IMPORTANT_MOVE_SETTINGS_BY_LEVEL[eval_metrics.DEFAULT_IMPORTANT_MOVE_LEVEL]
        )

        def fmt_val(val, default="unknown"):
            return default if val in [None, ""] else str(val)

        def fmt_float(val):
            return "unknown" if val is None else f"{val:.1f}"

        def normalize_name(name: Optional[str]) -> str:
            if not name:
                return ""
            return re.sub(r"[^0-9a-z]+", "", str(name).casefold())

        def read_aliases(value) -> List[str]:
            if not value:
                return []
            if isinstance(value, list):
                return [str(v) for v in value if v]
            if isinstance(value, str):
                return [v.strip() for v in re.split(r"[;,]", value) if v.strip()]
            return []

        # Meta
        board_x, board_y = self.board_size
        filename = os.path.splitext(os.path.basename(self.sgf_filename or ""))[0] or fmt_val(
            self.root.get_property("GN", None), default=self.game_id
        )
        meta_lines = [
            f"- Board: {board_x}x{board_y}",
            f"- Komi: {fmt_val(self.komi)}",
            f"- Rules: {fmt_val(self.rules)}",
            f"- Handicap: {fmt_val(getattr(self.root, 'handicap', None), default='none')}",
            f"- Game: {filename}",
            f"- Date: {fmt_val(self.root.get_property('DT', None), default=self.game_id)}",
        ]

        pb = fmt_val(self.root.get_property("PB", None))
        pw = fmt_val(self.root.get_property("PW", None))
        br = self.root.get_property("BR", None)
        wr = self.root.get_property("WR", None)
        players_lines = [
            f"- Black: {pb}" + (f" ({br})" if br else ""),
            f"- White: {pw}" + (f" ({wr})" if wr else ""),
        ]

        focus_color = None
        if self.katrain:
            focus_name = self.katrain.config("general/my_player_name")
            focus_aliases = read_aliases(self.katrain.config("general/my_player_aliases"))
            focus_names = [n for n in [focus_name, *focus_aliases] if n]
            if focus_names:
                focus_tokens = {normalize_name(n) for n in focus_names if normalize_name(n)}
                pb_norm = normalize_name(pb)
                pw_norm = normalize_name(pw)
                match_black = pb_norm and any(n in pb_norm for n in focus_tokens)
                match_white = pw_norm and any(n in pw_norm for n in focus_tokens)
                if match_black != match_white:
                    focus_color = "B" if match_black else "W"

        # Phase 3: Process player_filter parameter
        # If player_filter is a username string, convert to "B" or "W"
        filtered_player = None
        if player_filter:
            if player_filter in ("B", "W"):
                filtered_player = player_filter
            else:
                # Try to match against player names
                user_norm = normalize_name(player_filter)
                pb_norm = normalize_name(pb)
                pw_norm = normalize_name(pw)
                match_black = pb_norm and user_norm in pb_norm
                match_white = pw_norm and user_norm in pw_norm
                if match_black and not match_white:
                    filtered_player = "B"
                elif match_white and not match_black:
                    filtered_player = "W"
                # If both or neither match, filtered_player stays None (show both)

        def worst_move_for(player: str) -> Optional[MoveEval]:
            moves = [mv for mv in snapshot.moves if mv.player == player and mv.points_lost is not None]
            return max(moves, key=lambda mv: mv.points_lost) if moves else None

        def mistake_label_from_loss(loss_val: Optional[float]) -> str:
            """Classify a loss value using the centralized classify_mistake function."""
            if loss_val is None:
                return "unknown"
            # Use classify_mistake for consistent thresholds across Karte and Summary
            category = classify_mistake(score_loss=loss_val, winrate_loss=None)
            return category.value

        def summary_lines_for(player: str) -> List[str]:
            player_moves = [mv for mv in snapshot.moves if mv.player == player]
            total_lost = sum(max(0.0, mv.points_lost) for mv in player_moves if mv.points_lost is not None)
            worst = worst_move_for(player)
            return [
                f"- Moves analyzed: {len(player_moves)}",
                f"- Total points lost: {fmt_float(total_lost)}",
                "- Worst move: "
                + (
                    f"#{worst.move_number} {worst.player or '-'} {worst.gtp or '-'} "
                    f"loss {fmt_float(worst.points_lost)} ({mistake_label_from_loss(worst.points_lost)})"
                    if worst
                    else "unknown"
                ),
            ]

        def opponent_summary_for(focus_player: str) -> List[str]:
            """相手プレイヤーのサマリーを生成（Phase 4: 相手情報追加）"""
            opponent = "W" if focus_player == "B" else "B"
            opponent_moves = [mv for mv in snapshot.moves if mv.player == opponent]
            if not opponent_moves:
                return []
            total_lost = sum(max(0.0, mv.points_lost) for mv in opponent_moves if mv.points_lost is not None)
            worst = worst_move_for(opponent)
            opponent_name = pw if opponent == "W" else pb
            return [
                f"## Opponent Summary ({opponent_name})",
                f"- Moves analyzed: {len(opponent_moves)}",
                f"- Total points lost: {fmt_float(total_lost)}",
                "- Worst move: " + (
                    f"#{worst.move_number} {worst.player or '-'} {worst.gtp or '-'} "
                    f"loss {fmt_float(worst.points_lost)} ({mistake_label_from_loss(worst.points_lost)})"
                    if worst else "unknown"
                ),
                ""
            ]

        def common_difficult_positions() -> List[str]:
            """両者とも損失が大きい局面を検出（Phase 4: 共通困難局面）"""
            # 連続する手（手番交代）で両者とも損失が大きい箇所を検出
            difficult = []
            moves_list = list(snapshot.moves)
            for i in range(len(moves_list) - 1):
                mv = moves_list[i]
                next_mv = moves_list[i + 1]
                # 両者の損失がそれぞれ2目以上
                if (mv.points_lost is not None and mv.points_lost >= 2.0 and
                    next_mv.points_lost is not None and next_mv.points_lost >= 2.0):
                    # 手番が交代していることを確認
                    if mv.player != next_mv.player:
                        total = mv.points_lost + next_mv.points_lost
                        # 黒/白の損失を正しく割り当て
                        if mv.player == "B":
                            b_loss, w_loss = mv.points_lost, next_mv.points_lost
                        else:
                            b_loss, w_loss = next_mv.points_lost, mv.points_lost
                        difficult.append((mv.move_number, b_loss, w_loss, total))

            if not difficult:
                return []

            difficult.sort(key=lambda x: x[3], reverse=True)
            lines = ["## Common Difficult Positions", ""]
            lines.append("Both players made significant errors (2+ points) in consecutive moves:")
            lines.append("")
            lines.append("| Move # | Black Loss | White Loss | Total Loss |")
            lines.append("|--------|------------|------------|------------|")
            for move_num, b_loss, w_loss, total in difficult[:5]:
                lines.append(f"| {move_num}-{move_num+1} | {b_loss:.1f} | {w_loss:.1f} | {total:.1f} |")
            lines.append("")
            return lines

        # Distributions using existing report helper if thresholds are available
        histogram = None
        if thresholds:
            try:
                from katrain.core import ai as ai_module

                _sum_stats, histogram, _ptloss = ai_module.game_report(self, thresholds=thresholds, depth_filter=None)

                def bucket_label(bucket_idx: int) -> str:
                    cls_idx = len(thresholds) - 1 - bucket_idx
                    if cls_idx == 0:
                        return f">= {thresholds[0]}"
                    if cls_idx == len(thresholds) - 1:
                        return f"< {thresholds[-2]}"
                    upper = thresholds[cls_idx - 1]
                    lower = thresholds[cls_idx]
                    return f"{lower} - {upper}"
            except Exception as exc:  # pragma: no cover - defensive fallback
                self.katrain.log(f"Failed to build histogram for Karte export: {exc}", OUTPUT_DEBUG)
                histogram = None

        def distribution_lines_for(player: str) -> List[str]:
            if histogram is None:
                return ["- Mistake buckets: unknown"]
            lines = ["- Mistake buckets (points lost):"]
            for idx, bucket in enumerate(histogram):
                label = bucket_label(idx)
                lines.append(f"  - {label}: {bucket[player]}")
            # Removed: "Freedom buckets: unknown" (Phase 8: always unknown, no value for LLM)
            return lines

        # Important moves table (top N derived from existing settings)
        important_moves = self.get_important_move_evals(level=level)

        # Phase 2: コンテキスト情報（候補手数・最善手差・危険度・最善手）を取得
        def get_context_info_for_move(move_eval) -> dict:
            """MoveEval から候補手数・最善手差・危険度・最善手を取得

            CRITICAL FIX: Best move and candidates are now extracted from the PRE-MOVE node
            (node.parent), not the post-move node. This ensures we see the candidate moves
            that were available BEFORE the move was played.

            Returns:
                {
                    "candidates": int or None,
                    "best_gap": float or None (0.0-1.0),
                    "danger": str or None ("High"/"Mid"/"Low"),
                    "best_move": str or None (GTP format, e.g., "Q16")
                }
            """
            context = {
                "candidates": None,
                "best_gap": None,
                "danger": None,
                "best_move": None,
            }

            try:
                node = self._find_node_by_move_number(move_eval.move_number)
                if not node:
                    return context

                # CRITICAL: Use parent node for candidate moves (PRE-MOVE position)
                # This is the position BEFORE the move was played, which contains
                # the candidate moves that were available to the player.
                parent_node = getattr(node, "parent", None)

                if parent_node and hasattr(parent_node, 'candidate_moves'):
                    candidate_moves = parent_node.candidate_moves
                    if candidate_moves:
                        context["candidates"] = len(candidate_moves)

                        # Best move is the first candidate (order=0)
                        if candidate_moves:
                            best_candidate = candidate_moves[0]
                            context["best_move"] = best_candidate.get("move")

                        # Best gap: find the played move in parent's candidates
                        actual_move_gtp = move_eval.gtp
                        if actual_move_gtp:
                            for candidate in candidate_moves:
                                if candidate.get("move") == actual_move_gtp:
                                    # Use scoreLost or winrateLost if available
                                    score_lost = candidate.get("scoreLost")
                                    winrate_lost = candidate.get("winrateLost")
                                    if winrate_lost is not None:
                                        context["best_gap"] = winrate_lost
                                    break

                # 危険度（board_analysis から）- uses current node for danger assessment
                from katrain.core import board_analysis
                board_state = board_analysis.analyze_board_at_node(self, node)

                # プレイヤーのグループの最大危険度
                player = move_eval.player
                if player:
                    my_groups = [g for g in board_state.groups if g.color == player]
                    if my_groups:
                        max_danger = max(
                            (board_state.danger_scores.get(g.group_id, 0) for g in my_groups),
                            default=0
                        )

                        if max_danger >= 50:
                            context["danger"] = "High"
                        elif max_danger >= 25:
                            context["danger"] = "Mid"
                        else:
                            context["danger"] = "Low"

            except Exception as e:
                # エラー時は None のまま
                if self.katrain:
                    self.katrain.log(f"Failed to get context info for move #{move_eval.move_number}: {e}", OUTPUT_DEBUG)

            return context

        def important_lines_for(player: str, label: str) -> List[str]:
            player_moves = [mv for mv in important_moves if mv.player == player][: settings.max_moves]
            lines = [f"## Important Moves ({label}) Top {len(player_moves) or settings.max_moves}"]
            if player_moves:
                # Added "Best" column for best move from PRE-MOVE node
                lines.append("| # | P | Coord | Loss | Best | Candidates | Best Gap | Danger | Mistake | Reason |")
                lines.append("|---|---|-------|------|------|------------|----------|--------|---------|--------|")
                for mv in player_moves:
                    # canonical loss を使用（常に >= 0）
                    loss = get_canonical_loss_from_move(mv)
                    mistake = mistake_label_from_loss(loss)
                    reason_str = ", ".join(mv.reason_tags) if mv.reason_tags else "-"

                    # コンテキスト情報を取得 (now includes best_move from PRE-MOVE node)
                    context = get_context_info_for_move(mv)
                    best_move_str = context["best_move"] or "-"
                    candidates_str = str(context["candidates"]) if context["candidates"] is not None else "-"
                    # PR1-3: Robust best_gap formatting using rounding
                    # If int(round(val)) == 0, print "0%" to avoid "-0%" display
                    if context["best_gap"] is not None:
                        best_gap_val = context["best_gap"] * 100
                        rounded_val = int(round(best_gap_val))
                        if rounded_val == 0:
                            best_gap_str = "0%"
                        else:
                            best_gap_str = f"{rounded_val}%"
                    else:
                        best_gap_str = "-"
                    danger_str = context["danger"] or "-"

                    lines.append(
                        f"| {mv.move_number} | {mv.player or '-'} | {mv.gtp or '-'} | "
                        f"{fmt_float(loss)} | {best_move_str} | {candidates_str} | {best_gap_str} | {danger_str} | "
                        f"{mistake} | {reason_str} |"
                    )
            else:
                lines.append("- No important moves found.")
            return lines

        def reason_tags_distribution_for(player: str, label: str) -> List[str]:
            """Phase 12: 理由タグ分布を生成（1局カルテ用）"""
            player_moves = [mv for mv in important_moves if mv.player == player]

            # タグをカウント
            reason_tags_counts = {}
            for mv in player_moves:
                for tag in mv.reason_tags:
                    reason_tags_counts[tag] = reason_tags_counts.get(tag, 0) + 1

            lines = [f"## Reason Tags Distribution ({label})"]
            if reason_tags_counts:
                # カウント降順でソート
                sorted_tags = sorted(
                    reason_tags_counts.items(),
                    key=lambda x: x[1],
                    reverse=True
                )

                lines.append("")
                for tag, count in sorted_tags:
                    label_text = eval_metrics.REASON_TAG_LABELS.get(tag, tag)
                    lines.append(f"- {label_text}: {count}")
            else:
                lines.append("")
                lines.append("- No reason tags detected.")

            lines.append("")
            return lines

        focus_label = "Focus"

        # Build Definitions section (uses SKILL_PRESETS thresholds, not hardcoded)
        def definitions_section() -> List[str]:
            """Build the Definitions section with thresholds from SKILL_PRESETS."""
            preset = eval_metrics.SKILL_PRESETS.get("standard", eval_metrics.SKILL_PRESETS[eval_metrics.DEFAULT_SKILL_PRESET])
            t1, t2, t3 = preset.score_thresholds  # (1.0, 2.5, 5.0) for standard

            # Get phase thresholds for this board size
            opening_end, middle_end = eval_metrics.get_phase_thresholds(board_x)

            lines = [
                "## Definitions",
                "",
                "| Metric | Definition |",
                "|--------|------------|",
                "| Points Lost | Score difference between actual move and best move (clamped to ≥0) |",
                f"| Good | Loss < {t1:.1f} pts |",
                f"| Inaccuracy | Loss {t1:.1f} - {t2:.1f} pts |",
                f"| Mistake | Loss {t2:.1f} - {t3:.1f} pts |",
                f"| Blunder | Loss ≥ {t3:.1f} pts |",
                f"| Phase ({board_x}x{board_y}) | Opening: <{opening_end}, Middle: {opening_end}-{middle_end-1}, Endgame: ≥{middle_end} |",
                "",
            ]
            return lines

        # Build Data Quality section
        def data_quality_section() -> List[str]:
            """Build the Data Quality section with reliability statistics."""
            rel_stats = eval_metrics.compute_reliability_stats(snapshot.moves)

            lines = [
                "## Data Quality",
                "",
                f"- Moves analyzed: {rel_stats.total_moves}",
                f"- Reliable (visits ≥ {eval_metrics.RELIABILITY_VISITS_THRESHOLD}): "
                f"{rel_stats.reliable_count} ({rel_stats.reliability_pct:.1f}%)",
                f"- Low-confidence: {rel_stats.low_confidence_count} ({rel_stats.low_confidence_pct:.1f}%)",
            ]

            if rel_stats.moves_with_visits > 0:
                lines.append(f"- Avg visits: {rel_stats.avg_visits:,.0f}")
                # PR1-2: Add max visits to help users understand the data
                if rel_stats.max_visits > 0:
                    lines.append(f"- Max visits: {rel_stats.max_visits:,}")
            if rel_stats.zero_visits_count > 0:
                lines.append(f"- No visits data: {rel_stats.zero_visits_count}")

            if rel_stats.is_low_reliability:
                lines.append("")
                lines.append("⚠ Low analysis reliability (<20%). Results may be unstable.")

            # PR1-2: Add note about measured vs configured values
            lines.append("")
            lines.append("*Visits are measured from KataGo analysis (root_visits).*")

            lines.append("")
            return lines

        # Assemble sections
        sections = ["## Meta", *meta_lines, ""]
        sections += ["## Players", *players_lines, ""]
        sections += ["## Notes", "- loss is measured for the player who played the move.", ""]
        sections += definitions_section()
        sections += data_quality_section()

        # Phase 3: Apply player filter to sections
        if filtered_player is None:
            # Show both players (current behavior)
            if focus_color:
                focus_name = "Black" if focus_color == "B" else "White"
                sections += [f"## Summary (Focus: {focus_name})", *summary_lines_for(focus_color), ""]
                # Phase 4: focus_color がある場合、相手サマリーを追加
                sections += opponent_summary_for(focus_color)
            sections += ["## Summary (Black)", *summary_lines_for("B"), ""]
            sections += ["## Summary (White)", *summary_lines_for("W"), ""]
            if focus_color:
                focus_name = "Black" if focus_color == "B" else "White"
                sections += [f"## Distributions (Focus: {focus_name})", *distribution_lines_for(focus_color), ""]
            sections += ["## Distributions (Black)", *distribution_lines_for("B"), ""]
            sections += ["## Distributions (White)", *distribution_lines_for("W"), ""]
            # Phase 4: focus_color がある場合、共通困難局面を追加
            if focus_color:
                sections += common_difficult_positions()
        else:
            # Show only filtered player
            filtered_name = "Black" if filtered_player == "B" else "White"
            # Show focus section only if it matches the filter
            if focus_color and focus_color == filtered_player:
                sections += [f"## Summary (Focus: {filtered_name})", *summary_lines_for(focus_color), ""]
            sections += [f"## Summary ({filtered_name})", *summary_lines_for(filtered_player), ""]
            # Phase 4: 相手サマリーを追加
            sections += opponent_summary_for(filtered_player)
            if focus_color and focus_color == filtered_player:
                sections += [f"## Distributions (Focus: {filtered_name})", *distribution_lines_for(focus_color), ""]
            sections += [f"## Distributions ({filtered_name})", *distribution_lines_for(filtered_player), ""]
            # Phase 4: 共通困難局面を追加
            sections += common_difficult_positions()

        # 弱点仮説セクション（Phase 7で追加）
        def weakness_hypothesis_for(player: str, label: str) -> List[str]:
            """単局の弱点仮説を生成"""
            player_moves = [mv for mv in snapshot.moves if mv.player == player]
            if not player_moves:
                return [f"## Weakness Hypothesis ({label})", "- No data available.", ""]

            # 盤サイズを取得（board_size は (x, y) タプル）
            board_x, _ = self.board_size

            # Phase × Mistake クロス集計
            phase_mistake_loss = {}
            phase_mistake_count = {}

            for mv in player_moves:
                if mv.points_lost is None:
                    continue

                # Phase 判定（手数ベース、盤サイズ対応）
                phase = eval_metrics.classify_game_phase(mv.move_number, board_size=board_x)

                # Mistake 分類
                loss = max(0.0, mv.points_lost)
                if loss < 1.0:
                    category = "GOOD"
                elif loss < 3.0:
                    category = "INACCURACY"
                elif loss < 7.0:
                    category = "MISTAKE"
                else:
                    category = "BLUNDER"

                key = (phase, category)
                phase_mistake_count[key] = phase_mistake_count.get(key, 0) + 1
                if loss > 0:
                    phase_mistake_loss[key] = phase_mistake_loss.get(key, 0.0) + loss

            # 損失が大きい順にソート（GOOD は除外）
            sorted_combos = sorted(
                [(k, v) for k, v in phase_mistake_loss.items() if k[1] != "GOOD" and v > 0],
                key=lambda x: x[1],
                reverse=True
            )

            phase_names = {"opening": "Opening", "middle": "Middle game", "yose": "Endgame"}
            cat_names_ja = {
                "BLUNDER": "大悪手",
                "MISTAKE": "悪手",
                "INACCURACY": "軽微なミス",
            }

            lines = [f"## Weakness Hypothesis ({label})", ""]
            if sorted_combos:
                # 上位2つの弱点を抽出
                for i, (key, loss) in enumerate(sorted_combos[:2]):
                    phase, category = key
                    count = phase_mistake_count.get(key, 0)
                    lines.append(
                        f"{i+1}. **{phase_names.get(phase, phase)}の{cat_names_ja.get(category, category)}** "
                        f"({count}回、損失{loss:.1f}目)"
                    )
            else:
                lines.append("- 明確な弱点パターンは検出されませんでした。")

            lines.append("")
            return lines

        # Practice Priorities を生成（共有アグリゲータを使用）
        def practice_priorities_for(player: str, label: str) -> List[str]:
            """単局の練習優先事項を生成"""
            player_moves = [mv for mv in snapshot.moves if mv.player == player]
            if not player_moves:
                return [f"## Practice Priorities ({label})", "- No data available.", ""]

            # 盤サイズを取得（board_size は (x, y) タプル）
            board_x, _ = self.board_size
            # 共有アグリゲータで Phase × Mistake 統計を計算（盤サイズ対応）
            stats = aggregate_phase_mistake_stats(player_moves, board_size=board_x)

            # 優先項目を取得
            priorities = get_practice_priorities_from_stats(stats, max_priorities=2)

            lines = [f"## Practice Priorities ({label})", ""]
            lines.append("Based on the data above, consider focusing on:")
            lines.append("")
            if priorities:
                for i, priority in enumerate(priorities, 1):
                    lines.append(f"- {i}. {priority}")
            else:
                lines.append("- No specific priorities identified. Keep up the good work!")
            lines.append("")
            return lines

        # Mistake Streaks を検出して表示
        def mistake_streaks_for(player: str, label: str) -> List[str]:
            """同一プレイヤーの連続ミスを検出して表示"""
            player_moves = [mv for mv in snapshot.moves if mv.player == player]
            if not player_moves:
                return []

            # 連続ミスを検出（2回以上連続、損失2目以上）
            streaks = detect_mistake_streaks(
                player_moves,
                loss_threshold=2.0,
                min_consecutive=2,
            )

            if not streaks:
                return []

            lines = [f"## Mistake Streaks ({label})", ""]
            lines.append("Consecutive mistakes by the same player:")
            lines.append("")
            for i, s in enumerate(streaks, 1):
                lines.append(
                    f"- **Streak {i}**: moves {s.start_move}-{s.end_move} "
                    f"({s.move_count} mistakes, {s.total_loss:.1f} pts lost, avg {s.avg_loss:.1f} pts)"
                )
            lines.append("")
            return lines

        # Phase 3: Apply player filter to weakness hypothesis and important moves
        if filtered_player is None:
            # Show both players
            if focus_color:
                focus_name = "Black" if focus_color == "B" else "White"
                sections += weakness_hypothesis_for(focus_color, focus_name)
                sections += practice_priorities_for(focus_color, focus_name)
                sections += mistake_streaks_for(focus_color, focus_name)

            if focus_color:
                sections += important_lines_for(focus_color, focus_label)
                sections.append("")
                # Phase 12: タグ分布を Focus player に追加
                sections += reason_tags_distribution_for(focus_color, focus_label)
            sections += important_lines_for("B", "Black")
            sections.append("")
            # Phase 12: タグ分布を Black に追加
            sections += reason_tags_distribution_for("B", "Black")
            sections += important_lines_for("W", "White")
            sections.append("")
            # Phase 12: タグ分布を White に追加
            sections += reason_tags_distribution_for("W", "White")
        else:
            # Show only filtered player
            filtered_name = "Black" if filtered_player == "B" else "White"
            if focus_color and focus_color == filtered_player:
                sections += weakness_hypothesis_for(focus_color, filtered_name)
                sections += practice_priorities_for(focus_color, filtered_name)
                sections += mistake_streaks_for(focus_color, filtered_name)

            if focus_color and focus_color == filtered_player:
                sections += important_lines_for(focus_color, focus_label)
                sections.append("")
                sections += reason_tags_distribution_for(focus_color, focus_label)
            sections += important_lines_for(filtered_player, filtered_name)
            sections.append("")
            sections += reason_tags_distribution_for(filtered_player, filtered_name)

        return "\n".join(sections)

    @staticmethod
    def build_summary_report(
        game_data_list: List[GameSummaryData],
        focus_player: Optional[str] = None
    ) -> str:
        """
        複数局から統計まとめを生成（Phase 6）

        Args:
            game_data_list: 各対局のデータリスト
            focus_player: 集計対象プレイヤー名（Noneなら全プレイヤー）

        Returns:
            Markdown形式のまとめレポート
        """
        if not game_data_list:
            return "# Multi-Game Summary\n\nNo games provided."

        # プレイヤー別に統計を集計
        player_stats = Game._aggregate_player_stats(game_data_list, focus_player)

        # Markdownセクションをフォーマット
        sections = ["# Multi-Game Summary\n"]
        sections.append(Game._format_meta_section(game_data_list, focus_player))

        for player, stats in player_stats.items():
            sections.append("")
            sections.append(Game._format_overall_stats(player, stats))
            sections.append("")
            sections.append(Game._format_mistake_distribution(player, stats))
            sections.append("")
            sections.append(Game._format_freedom_distribution(player, stats))
            sections.append("")
            sections.append(Game._format_phase_breakdown(player, stats))
            sections.append("")
            # Phase × Mistake クロス集計テーブル追加
            sections.append(Game._format_phase_mistake_breakdown(player, stats))
            sections.append("")
            sections.append(Game._format_top_worst_moves(player, stats))
            sections.append("")
            sections.append(Game._format_weakness_hypothesis(player, stats))
            sections.append("")
            sections.append(Game._format_practice_priorities(player, stats))

        return "\n".join(sections)

    @staticmethod
    def _aggregate_player_stats(
        game_data_list: List[GameSummaryData],
        focus_player: Optional[str] = None
    ) -> Dict[str, SummaryStats]:
        """プレイヤー別に統計を集計"""
        player_stats: Dict[str, SummaryStats] = {}

        for game_data in game_data_list:
            for player_color in ["B", "W"]:
                player_name = (
                    game_data.player_black if player_color == "B"
                    else game_data.player_white
                )

                # focus_player指定がある場合、それ以外はスキップ
                if focus_player and player_name != focus_player:
                    continue

                # プレイヤー統計を初期化
                if player_name not in player_stats:
                    player_stats[player_name] = SummaryStats(
                        player_name=player_name,
                        mistake_counts={cat: 0 for cat in MistakeCategory},
                        mistake_total_loss={cat: 0.0 for cat in MistakeCategory},
                        freedom_counts={diff: 0 for diff in PositionDifficulty},
                        phase_moves={"opening": 0, "middle": 0, "yose": 0, "unknown": 0},
                        phase_loss={"opening": 0.0, "middle": 0.0, "yose": 0.0, "unknown": 0.0},
                    )

                stats = player_stats[player_name]
                stats.total_games += 1

                # このプレイヤーの手のみを集計
                player_moves = [m for m in game_data.snapshot.moves if m.player == player_color]
                stats.total_moves += len(player_moves)

                for move in player_moves:
                    # 損失を集計（canonical loss: 常に >= 0）
                    loss = get_canonical_loss_from_move(move)
                    if loss > 0:
                        stats.total_points_lost += loss

                    # ミス分類を集計
                    if move.mistake_category:
                        stats.mistake_counts[move.mistake_category] += 1
                        if loss > 0:
                            stats.mistake_total_loss[move.mistake_category] += loss

                    # Freedom（手の自由度）を集計
                    if move.position_difficulty:
                        stats.freedom_counts[move.position_difficulty] += 1

                    # 局面タイプを集計
                    phase = move.tag or "unknown"
                    stats.phase_moves[phase] = stats.phase_moves.get(phase, 0) + 1
                    if loss > 0:
                        stats.phase_loss[phase] = stats.phase_loss.get(phase, 0.0) + loss

                    # Phase × MistakeCategory クロス集計
                    if move.mistake_category:
                        key = (phase, move.mistake_category)
                        stats.phase_mistake_counts[key] = stats.phase_mistake_counts.get(key, 0) + 1
                        if loss > 0:
                            stats.phase_mistake_loss[key] = stats.phase_mistake_loss.get(key, 0.0) + loss

                    # 最悪手を記録（Top 10を保持）
                    if loss > 0.5:  # 0.5目以上の損失のみ
                        stats.worst_moves.append((game_data.game_name, move))

        # 各プレイヤーの統計を完成させる
        for stats in player_stats.values():
            if stats.total_moves > 0:
                stats.avg_points_lost_per_move = stats.total_points_lost / stats.total_moves

            # 最悪手をソートする（Top 10への絞り込みは _format_top_worst_moves で実施）
            stats.worst_moves.sort(key=lambda x: x[1].points_lost or x[1].score_loss or 0, reverse=True)

        return player_stats

    @staticmethod
    def _format_meta_section(game_data_list: List[GameSummaryData], focus_player: Optional[str]) -> str:
        """メタ情報セクションを生成"""
        lines = ["## Meta"]
        lines.append(f"- Games analyzed: {len(game_data_list)}")

        # プレイヤー情報
        all_players = set()
        for gd in game_data_list:
            all_players.add(gd.player_black)
            all_players.add(gd.player_white)

        if focus_player:
            lines.append(f"- Focus player: {focus_player}")
        else:
            lines.append(f"- Players: {', '.join(sorted(all_players))}")

        # 日付範囲
        dates = [gd.date for gd in game_data_list if gd.date]
        if dates:
            lines.append(f"- Date range: {min(dates)} to {max(dates)}")

        # 生成日時
        now = datetime.now().strftime("%Y-%m-%d %H:%M")
        lines.append(f"- Generated: {now}")

        return "\n".join(lines)

    @staticmethod
    def _format_overall_stats(player_name: str, stats: SummaryStats) -> str:
        """総合統計セクションを生成"""
        lines = [f"## Overall Statistics ({player_name})"]
        lines.append(f"- Total games: {stats.total_games}")
        lines.append(f"- Total moves analyzed: {stats.total_moves}")
        lines.append(f"- Total points lost: {stats.total_points_lost:.1f}")
        lines.append(f"- Average points lost per move: {stats.avg_points_lost_per_move:.2f}")

        if stats.worst_moves:
            worst_game, worst_move = stats.worst_moves[0]
            loss = worst_move.points_lost if worst_move.points_lost else worst_move.score_loss
            lines.append(
                f"- Worst single move: {worst_game} #{worst_move.move_number} "
                f"{worst_move.gtp or '-'} ({loss:.1f} points)"
            )

        return "\n".join(lines)

    @staticmethod
    def _format_mistake_distribution(player_name: str, stats: SummaryStats) -> str:
        """ミス分類分布セクションを生成"""
        lines = [f"## Mistake Distribution ({player_name})"]
        lines.append("| Category | Count | Percentage | Avg Loss |")
        lines.append("|----------|-------|------------|----------|")

        category_labels = {
            MistakeCategory.GOOD: "Good",
            MistakeCategory.INACCURACY: "Inaccuracy",
            MistakeCategory.MISTAKE: "Mistake",
            MistakeCategory.BLUNDER: "Blunder",
        }

        for cat in [MistakeCategory.GOOD, MistakeCategory.INACCURACY,
                    MistakeCategory.MISTAKE, MistakeCategory.BLUNDER]:
            count = stats.mistake_counts.get(cat, 0)
            pct = stats.get_mistake_percentage(cat)
            avg_loss = stats.get_mistake_avg_loss(cat)
            lines.append(
                f"| {category_labels[cat]} | {count} | {pct:.1f}% | {avg_loss:.2f} |"
            )

        return "\n".join(lines)

    @staticmethod
    def _format_freedom_distribution(player_name: str, stats: SummaryStats) -> str:
        """Freedom（手の自由度）分布セクションを生成"""
        lines = [f"## Freedom Distribution ({player_name})"]
        lines.append("| Difficulty | Count | Percentage |")
        lines.append("|------------|-------|------------|")

        difficulty_labels = {
            PositionDifficulty.EASY: "Easy (wide)",
            PositionDifficulty.NORMAL: "Normal",
            PositionDifficulty.HARD: "Hard (narrow)",
            PositionDifficulty.ONLY_MOVE: "Only move",
        }

        for diff in [PositionDifficulty.EASY, PositionDifficulty.NORMAL,
                     PositionDifficulty.HARD, PositionDifficulty.ONLY_MOVE]:
            count = stats.freedom_counts.get(diff, 0)
            pct = stats.get_freedom_percentage(diff)
            lines.append(
                f"| {difficulty_labels[diff]} | {count} | {pct:.1f}% |"
            )

        return "\n".join(lines)

    @staticmethod
    def _format_phase_breakdown(player_name: str, stats: SummaryStats) -> str:
        """局面タイプ別内訳セクションを生成"""
        lines = [f"## Phase Breakdown ({player_name})"]
        lines.append("| Phase | Moves | Points Lost | Avg Loss |")
        lines.append("|-------|-------|-------------|----------|")

        phase_labels = {
            "opening": "Opening",
            "middle": "Middle game",
            "yose": "Endgame",
            "unknown": "Unknown",
        }

        for phase in ["opening", "middle", "yose", "unknown"]:
            count = stats.phase_moves.get(phase, 0)
            loss = stats.phase_loss.get(phase, 0.0)
            avg_loss = stats.get_phase_avg_loss(phase)
            lines.append(
                f"| {phase_labels.get(phase, phase)} | {count} | {loss:.1f} | {avg_loss:.2f} |"
            )

        return "\n".join(lines)

    @staticmethod
    def _format_phase_mistake_breakdown(player_name: str, stats: SummaryStats) -> str:
        """Phase × Mistake クロス集計セクションを生成"""
        lines = [f"## Phase × Mistake Breakdown ({player_name})"]
        lines.append("| Phase | Good | Inaccuracy | Mistake | Blunder | Total Loss |")
        lines.append("|-------|------|------------|---------|---------|------------|")

        phase_labels = {
            "opening": "Opening",
            "middle": "Middle game",
            "yose": "Endgame",
            "unknown": "Unknown",
        }

        for phase in ["opening", "middle", "yose"]:
            cells = [phase_labels.get(phase, phase)]

            for cat in [MistakeCategory.GOOD, MistakeCategory.INACCURACY,
                        MistakeCategory.MISTAKE, MistakeCategory.BLUNDER]:
                count = stats.phase_mistake_counts.get((phase, cat), 0)
                loss = stats.phase_mistake_loss.get((phase, cat), 0.0)

                if count > 0 and cat != MistakeCategory.GOOD:
                    cells.append(f"{count} ({loss:.1f})")
                else:
                    cells.append(str(count))

            # Total loss for this phase
            phase_total_loss = stats.phase_loss.get(phase, 0.0)
            cells.append(f"{phase_total_loss:.1f}")

            lines.append("| " + " | ".join(cells) + " |")

        return "\n".join(lines)

    @staticmethod
    def _convert_sgf_to_gtp_coord(sgf_coord: str, board_size: int = 19) -> str:
        """
        SGF座標（例: 'll', 'rf'）を人間用座標（例: 'L12', 'R6'）に変換

        Args:
            sgf_coord: SGF形式の座標（2文字のアルファベット）
            board_size: 盤面サイズ（デフォルト19路）

        Returns:
            GTP形式の座標（例: 'R6'）、変換失敗時は元の文字列
        """
        if not sgf_coord or len(sgf_coord) != 2:
            return sgf_coord

        try:
            # Move.SGF_COORD を使って変換
            x = Move.SGF_COORD.index(sgf_coord[0])
            y = board_size - Move.SGF_COORD.index(sgf_coord[1]) - 1
            return f"{Move.GTP_COORD[x]}{y + 1}"
        except (ValueError, IndexError):
            return sgf_coord

    @staticmethod
    def _detect_urgent_miss_sequences(worst_moves: List, threshold_loss: float = 20.0, min_consecutive: int = 3):
        """
        連続する大損失手を「急場見逃しパターン」として検出

        Args:
            worst_moves: [(game_name, move), ...] のリスト
            threshold_loss: 損失閾値（デフォルト20目）
            min_consecutive: 最小連続手数（デフォルト3手）

        Returns:
            sequences: 検出されたシーケンスのリスト
            filtered_moves: 急場見逃し区間を除外した通常のワースト手リスト
        """
        sequences = []
        filtered_moves = []
        current_seq = None

        # worst_movesを手数でソート（同じゲーム内で連続しているかチェックするため）
        sorted_moves = sorted(worst_moves, key=lambda x: (x[0], x[1].move_number))

        for i, (game_name, move) in enumerate(sorted_moves):
            loss = move.points_lost if move.points_lost else move.score_loss or 0

            if loss >= threshold_loss:
                if current_seq is None:
                    # 新しいシーケンス開始
                    current_seq = {
                        'game': game_name,
                        'start': move.move_number,
                        'end': move.move_number,
                        'moves': [(game_name, move)],
                        'total_loss': loss,
                        'count': 1
                    }
                elif current_seq['game'] == game_name and move.move_number <= current_seq['end'] + 2:
                    # 連続している（1手スキップまで許容）
                    current_seq['end'] = move.move_number
                    current_seq['moves'].append((game_name, move))
                    current_seq['total_loss'] += loss
                    current_seq['count'] += 1
                else:
                    # 連続が途切れた
                    if current_seq['count'] >= min_consecutive:
                        sequences.append(current_seq)
                    else:
                        # 閾値を超えているが連続していない → 通常のワースト手に追加
                        filtered_moves.extend(current_seq['moves'])

                    # 新しいシーケンス開始
                    current_seq = {
                        'game': game_name,
                        'start': move.move_number,
                        'end': move.move_number,
                        'moves': [(game_name, move)],
                        'total_loss': loss,
                        'count': 1
                    }
            else:
                # 閾値未満
                if current_seq:
                    if current_seq['count'] >= min_consecutive:
                        sequences.append(current_seq)
                    else:
                        # 閾値を超えているが連続していない → 通常のワースト手に追加
                        filtered_moves.extend(current_seq['moves'])
                    current_seq = None

                # 通常のワースト手に追加
                filtered_moves.append((game_name, move))

        # 最後のシーケンス処理
        if current_seq:
            if current_seq['count'] >= min_consecutive:
                sequences.append(current_seq)
            else:
                filtered_moves.extend(current_seq['moves'])

        return sequences, filtered_moves

    @staticmethod
    def _format_top_worst_moves(player_name: str, stats: SummaryStats) -> str:
        """最悪手Top 10セクションを生成（急場見逃しパターンを分離）"""
        lines = [f"## Top Worst Moves ({player_name})"]

        if not stats.worst_moves:
            lines.append("- No significant mistakes found.")
            return "\n".join(lines)

        # 急場見逃しパターンを検出
        sequences, filtered_moves = Game._detect_urgent_miss_sequences(
            stats.worst_moves,
            threshold_loss=20.0,
            min_consecutive=3
        )

        # 急場見逃しパターンがあれば表示
        if sequences:
            lines.append("")
            lines.append("**注意**: 以下の区間は双方が急場を見逃した可能性があります（損失20目超が3手以上連続）")
            lines.append("| Game | 手数範囲 | 連続 | 総損失 | 平均損失/手 |")
            lines.append("|------|---------|------|--------|------------|")

            for seq in sequences:
                short_game = seq['game'][:20] + "..." if len(seq['game']) > 23 else seq['game']
                avg_loss = seq['total_loss'] / seq['count']
                lines.append(
                    f"| {short_game} | #{seq['start']}-{seq['end']} | "
                    f"{seq['count']}手 | {seq['total_loss']:.1f}目 | {avg_loss:.1f}目 |"
                )
            lines.append("")

        # 通常のワースト手を表示
        if filtered_moves:
            # 損失でソートしてTop 10を取得
            filtered_moves.sort(key=lambda x: x[1].points_lost or x[1].score_loss or 0, reverse=True)
            display_moves = filtered_moves[:10]

            if sequences:
                lines.append("通常のワースト手（損失20目以下 or 単発）:")
            lines.append("| Game | # | P | Coord | Loss | Importance | Category |")
            lines.append("|------|---|---|-------|------|------------|----------|")

            mistake_labels = {
                MistakeCategory.GOOD: "GOOD",
                MistakeCategory.INACCURACY: "INACCURACY",
                MistakeCategory.MISTAKE: "MISTAKE",
                MistakeCategory.BLUNDER: "BLUNDER",
            }

            for game_name, move in display_moves:
                loss = move.points_lost if move.points_lost else move.score_loss
                importance = move.importance if hasattr(move, 'importance') and move.importance else loss
                mistake = mistake_labels.get(move.mistake_category, "UNKNOWN")

                # 座標変換（SGF座標→GTP座標）
                coord = move.gtp or '-'
                # move.gtp が2文字の小文字アルファベット（SGF座標）の場合、変換
                if coord and len(coord) == 2 and coord.isalpha() and coord.islower():
                    coord = Game._convert_sgf_to_gtp_coord(coord, 19)

                # ゲーム名が長い場合は短縮
                short_game = game_name[:20] + "..." if len(game_name) > 23 else game_name
                lines.append(
                    f"| {short_game} | {move.move_number} | {move.player or '-'} | "
                    f"{coord or '-'} | {loss:.1f} | {importance:.1f} | {mistake} |"
                )
        else:
            if sequences:
                lines.append("通常のワースト手: なし（すべて急場見逃しパターン）")

        return "\n".join(lines)

    @staticmethod
    def _format_weakness_hypothesis(player_name: str, stats: SummaryStats) -> str:
        """弱点仮説セクションを生成（複数局サマリー用）"""
        lines = [f"## Weakness Hypothesis ({player_name})", ""]

        # 急場見逃しパターンを検出（棋力別閾値を使用）
        # Note: このメソッドは static なので config にアクセスできない
        # 現在 UI では使われていないため、標準設定をデフォルトとする
        from katrain.core import eval_metrics
        urgent_config = eval_metrics.get_urgent_miss_config("standard")

        sequences, _ = Game._detect_urgent_miss_sequences(
            stats.worst_moves,
            threshold_loss=urgent_config.threshold_loss,
            min_consecutive=urgent_config.min_consecutive
        )

        # クロス集計から弱点を抽出
        priorities = stats.get_practice_priorities()

        if priorities:
            lines.append("Based on cross-tabulation analysis:")
            lines.append("")
            for priority in priorities:
                lines.append(f"- {priority}")
        else:
            lines.append("- 明確な弱点パターンは検出されませんでした。")

        # 急場見逃しがあれば追加
        if sequences:
            lines.append("")
            lines.append("**急場見逃しパターン**:")
            for seq in sequences:
                short_game = seq['game'][:20] + "..." if len(seq['game']) > 23 else seq['game']
                avg_loss = seq['total_loss'] / seq['count']
                lines.append(
                    f"- {short_game} #{seq['start']}-{seq['end']}: "
                    f"{seq['count']}手連続、総損失{seq['total_loss']:.1f}目（平均{avg_loss:.1f}目/手）"
                )

            lines.append("")
            lines.append("**推奨アプローチ**:")
            lines.append("- 詰碁（死活）訓練で読みの精度向上")
            lines.append("- 対局中、戦いの前に「自分の石は安全か？」「相手の弱点はどこか？」を確認")
            lines.append("- 急場見逃し区間のSGFを重点的に復習")

        return "\n".join(lines)

    @staticmethod
    def _format_practice_priorities(player_name: str, stats: SummaryStats) -> str:
        """練習優先事項セクションを生成"""
        lines = [f"## Practice Priorities ({player_name})"]
        lines.append("")
        lines.append("Based on the data above, consider focusing on:")
        lines.append("")

        priorities = stats.get_practice_priorities()

        if not priorities:
            lines.append("- No specific priorities identified. Keep up the good work!")
        else:
            for i, priority in enumerate(priorities, 1):
                lines.append(f"- {i}. {priority}")

        return "\n".join(lines)

    def log_important_moves_for_debug(
        self,
        *,
        level: str = "normal",
    ) -> None:
        """
        現在の対局（メイン分岐）について、
        「重要度スコアが大きい手」をログに出力するデバッグ用ヘルパー。

        - UI からはまだ呼ばない想定。
        - Phase 2 以降の機能実装時に挙動確認用として利用する。

        Args:
            level: 重要局面検出のレベル ("easy" / "normal" / "strict")
        """
        important_moves = self.get_important_move_evals(level=level)

        if not important_moves:
            settings = eval_metrics.IMPORTANT_MOVE_SETTINGS_BY_LEVEL.get(
                level,
                eval_metrics.IMPORTANT_MOVE_SETTINGS_BY_LEVEL[eval_metrics.DEFAULT_IMPORTANT_MOVE_LEVEL],
            )
            self.katrain.log(
                f"[Eval] No moves with importance > {settings.importance_threshold}",
                OUTPUT_INFO,
            )
            return

        # ヘッダ行
        settings = eval_metrics.IMPORTANT_MOVE_SETTINGS_BY_LEVEL.get(
            level,
            eval_metrics.IMPORTANT_MOVE_SETTINGS_BY_LEVEL[eval_metrics.DEFAULT_IMPORTANT_MOVE_LEVEL],
        )
        self.katrain.log(
            f"[Eval] Important moves (level={level}, "
            f"threshold={settings.importance_threshold}, max_moves={settings.max_moves})",
            OUTPUT_INFO,
        )

        # 各手を 1 行ずつログ出力
        for m in important_moves:
            self.katrain.log(
                (
                    "[Eval] move #{num} {player} {gtp} "
                    "score_before={sb} score_after={sa} "
                    "delta_score={ds} points_lost={pl} "
                    "importance={imp}"
                ).format(
                    num=m.move_number,
                    player=m.player or "-",
                    gtp=m.gtp or "-",
                    sb=None if m.score_before is None else f"{m.score_before:.2f}",
                    sa=None if m.score_after is None else f"{m.score_after:.2f}",
                    ds=None if m.delta_score is None else f"{m.delta_score:.2f}",
                    pl=None if m.points_lost is None else f"{m.points_lost:.2f}",
                    imp=None if m.importance_score is None else f"{m.importance_score:.2f}",
                ),
                OUTPUT_INFO,
            )

    # ------------------------------------------------------------------
    # 重要局面ナビ用のヘルパー
    # ------------------------------------------------------------------

    def _iter_main_branch_nodes(self):
        """
        ルートからメイン分岐（ordered_children[0] を辿った一本の線）
        上のノードだけを順に返す。
        """
        node = self.root
        while node.children:
            node = node.ordered_children[0]
            yield node

    def get_main_branch_node_before_move(self, move_number: int) -> Optional[GameNode]:
        """
        メイン分岐上で指定手数の直前局面を返す（なければ None）。
        move_number が 1 以下なら root を返す。
        """
        if move_number <= 1:
            return self.root

        target = move_number - 1
        for node in eval_metrics.iter_main_branch_nodes(self):
            current_move_no = len(node.nodes_from_root) - 1
            if current_move_no == target:
                return node
            if current_move_no > target:
                break
        return None

    def _compute_important_moves(self, max_moves: int = 20):
        """
        メイン分岐上のノードから「重要そうな手」を抽出して返す。

        戻り値: [(手数, 重要度スコア, GameNode), ...]  を
                手数昇順に並べたリスト。
        """
        candidates = []

        prev_score = None
        for node in self._iter_main_branch_nodes():
            move_no = len(node.nodes_from_root) - 1

            # 解析が終わっていない手はスキップ
            if not node.analysis_complete or node.score is None:
                continue

            points_lost = node.points_lost or 0.0
            delta_score = 0.0 if prev_score is None else abs(node.score - prev_score)

            # 「ミス or 大きな形勢変化」を重要度とする
            importance = max(points_lost, delta_score)

            # あまりに小さい変化はノイズとして捨てる
            if importance > 0.5:
                candidates.append((move_no, importance, node))

            prev_score = node.score

        # 1 手も取れなかった場合はフォールバック
        if not candidates:
            fallback = []
            prev_score = None
            for node in self._iter_main_branch_nodes():
                move_no = len(node.nodes_from_root) - 1
                if not node.analysis_complete or node.score is None:
                    continue

                points_lost = node.points_lost or 0.0
                delta_score = 0.0 if prev_score is None else abs(node.score - prev_score)
                fallback_importance = max(points_lost, delta_score)

                fallback.append((move_no, fallback_importance, node))
                prev_score = node.score

            # 重要度の大きい順に上位 max_moves 件
            fallback.sort(key=lambda t: t[1], reverse=True)
            candidates = fallback[:max_moves]
        else:
            # 通常ケース: 重要度の大きい順に上位 max_moves 件だけ残す
            candidates.sort(key=lambda t: t[1], reverse=True)
            candidates = candidates[:max_moves]

        # ナビゲーションで扱いやすいように、手数順に並べ直して返す
        candidates.sort(key=lambda t: t[0])
        return candidates

    def get_important_move_numbers(self, max_moves: int = 20):
        """
        「重要局面」と判定された手数のリストだけを返す。
        ScoreGraph などから呼ぶことを想定。
        """
        important = self._compute_important_moves(max_moves=max_moves)
        return [move_no for move_no, _importance, _node in important]

    def get_next_important_node(self, max_moves: int = 20):
        """
        現在の手より「後ろにある」重要局面ノードを返す。
        なければ None。
        """
        important = self._compute_important_moves(max_moves=max_moves)
        if not important:
            return None

        current_move_no = len(self.current_node.nodes_from_root) - 1

        for move_no, _importance, node in important:
            if move_no > current_move_no:
                return node

        # すべて現在手より前なら、今回はジャンプしない仕様にしておく
        return None

    def get_prev_important_node(self, max_moves: int = 20):
        """
        現在の手より「前にある」重要局面ノードを返す。
        なければ None。
        """
        important = self._compute_important_moves(max_moves=max_moves)
        if not important:
            return None

        current_move_no = len(self.current_node.nodes_from_root) - 1

        prev_node = None
        for move_no, _importance, node in important:
            if move_no >= current_move_no:
                break
            prev_node = node

        return prev_node

    def jump_to_next_important_move(self, max_moves: int = 20):
        """
        次の重要局面にジャンプする。
        実際に current_node を変更したノードを返す。なければ None。
        """
        node = self.get_next_important_node(max_moves=max_moves)
        if node is not None:
            self.set_current_node(node)
        return node

    def jump_to_prev_important_move(self, max_moves: int = 20):
        """
        前の重要局面にジャンプする。
        実際に current_node を変更したノードを返す。なければ None。
        """
        node = self.get_prev_important_node(max_moves=max_moves)
        if node is not None:
            self.set_current_node(node)
        return node

    def set_current_node(self, node):
        if self.insert_mode:
            self.katrain.controls.set_status(i18n._("finish inserting before navigating"), STATUS_ERROR)
            return
        super().set_current_node(node)

    def undo(self, n_times=1, stop_on_mistake=None):
        if self.insert_mode:  # in insert mode, undo = delete
            cn = self.current_node  # avoid race conditions
            if n_times == 1 and cn not in self.insert_after.nodes_from_root:
                cn.parent.children = [c for c in cn.parent.children if c != cn]
                self.current_node = cn.parent
                self._calculate_groups()
            return
        super().undo(n_times=n_times, stop_on_mistake=stop_on_mistake)

    def reset_current_analysis(self):
        cn = self.current_node
        engine = self.engines[cn.next_player]
        engine.terminate_queries(cn)
        cn.clear_analysis()
        cn.analyze(engine)

    def redo(self, n_times=1, stop_on_mistake=None):
        if self.insert_mode:
            return
        super().redo(n_times=n_times, stop_on_mistake=stop_on_mistake)

    def set_insert_mode(self, mode):
        if mode == "toggle":
            mode = not self.insert_mode
        if mode == self.insert_mode:
            return
        self.insert_mode = mode
        if mode:
            children = self.current_node.ordered_children
            if not children:
                self.insert_mode = False
            else:
                self.insert_after = self.current_node.ordered_children[0]
                self.katrain.controls.set_status(i18n._("starting insert mode"), STATUS_INFO)
        else:
            copy_from_node = self.insert_after
            copy_to_node = self.current_node
            num_copied = 0
            if copy_to_node != self.insert_after.parent:
                above_insertion_root = self.insert_after.parent.nodes_from_root
                already_inserted_moves = [
                    n.move for n in copy_to_node.nodes_from_root if n not in above_insertion_root and n.move
                ]
                try:
                    while True:
                        for m in copy_from_node.move_with_placements:
                            if m not in already_inserted_moves:
                                self._validate_move_and_update_chains(m, True)
                                # this inserts
                                copy_to_node = GameNode(
                                    parent=copy_to_node, properties=copy.deepcopy(copy_from_node.properties)
                                )
                                num_copied += 1
                        if not copy_from_node.children:
                            break
                        copy_from_node = copy_from_node.ordered_children[0]
                except IllegalMoveException:
                    pass  # illegal move = stop
                self._calculate_groups()  # recalculate groups
                self.katrain.controls.set_status(
                    i18n._("ending insert mode").format(num_copied=num_copied), STATUS_INFO
                )
                self.analyze_all_nodes(analyze_fast=True, even_if_present=False)
            else:
                self.katrain.controls.set_status("", STATUS_INFO)
        self.katrain.controls.move_tree.insert_node = self.insert_after if self.insert_mode else None
        self.katrain.controls.move_tree.redraw()
        self.katrain.update_state(redraw_board=True)

    # Play a Move from the current position, raise IllegalMoveException if invalid.
    def play(self, move: Move, ignore_ko: bool = False, analyze=True):
        played_node = super().play(move, ignore_ko)
        if analyze:
            if self.region_of_interest:
                played_node.analyze(self.engines[played_node.next_player], analyze_fast=True)
                played_node.analyze(self.engines[played_node.next_player], region_of_interest=self.region_of_interest)
            else:
                played_node.analyze(self.engines[played_node.next_player])
        return played_node

    def set_region_of_interest(self, region_of_interest):
        x1, x2, y1, y2 = region_of_interest
        xmin, xmax = min(x1, x2), max(x1, x2)
        ymin, ymax = min(y1, y2), max(y1, y2)
        szx, szy = self.board_size
        if not (xmin == xmax and ymin == ymax) and not (xmax - xmin + 1 >= szx and ymax - ymin + 1 >= szy):
            self.region_of_interest = [xmin, xmax, ymin, ymax]
        else:
            self.region_of_interest = None
        self.katrain.controls.set_status("", OUTPUT_INFO)

    def analyze_extra(self, mode, **kwargs):
        stones = {s.coords for s in self.stones}
        cn = self.current_node

        if mode == "stop":
            self.katrain.pondering = False
            for e in set(self.engines.values()):
                e.stop_pondering()
                e.terminate_queries()
            return

        engine = self.engines[cn.next_player]

        if mode == "ponder":
            cn.analyze(
                engine,
                ponder=True,
                priority=PRIORITY_EXTRA_ANALYSIS,
                region_of_interest=self.region_of_interest,
                time_limit=False,
            )
            return

        if mode == "extra":
            visits = cn.analysis_visits_requested + engine.config["max_visits"]
            self.katrain.controls.set_status(i18n._("extra analysis").format(visits=visits), STATUS_ANALYSIS)
            cn.analyze(
                engine,
                visits=visits,
                priority=PRIORITY_EXTRA_ANALYSIS,
                region_of_interest=self.region_of_interest,
                time_limit=False,
            )
            return

        if mode == "game":
            nodes = self.root.nodes_in_tree
            only_mistakes = kwargs.get("mistakes_only", False)
            move_range = kwargs.get("move_range", None)
            if move_range:
                if move_range[1] < move_range[0]:
                    move_range = reversed(move_range)
            threshold = self.katrain.config("trainer/eval_thresholds")[-4]
            if "visits" in kwargs:
                visits = kwargs["visits"]
            else:
                min_visits = min(node.analysis_visits_requested for node in nodes)
                visits = min_visits + engine.config["max_visits"]
            for node in nodes:
                max_point_loss = max(c.points_lost or 0 for c in [node] + node.children)
                if only_mistakes and max_point_loss <= threshold:
                    continue
                if move_range and (not node.depth - 1 in range(move_range[0], move_range[1] + 1)):
                    continue
                node.analyze(engine, visits=visits, priority=-1_000_000, time_limit=False, report_every=None)
            if not move_range:
                self.katrain.controls.set_status(i18n._("game re-analysis").format(visits=visits), STATUS_ANALYSIS)
            else:
                self.katrain.controls.set_status(
                    i18n._("move range analysis").format(
                        start_move=move_range[0], end_move=move_range[1], visits=visits
                    ),
                    STATUS_ANALYSIS,
                )
            return

        elif mode == "sweep":
            board_size_x, board_size_y = self.board_size

            if cn.analysis_exists:
                policy_grid = (
                    var_to_grid(self.current_node.policy, size=(board_size_x, board_size_y))
                    if self.current_node.policy
                    else None
                )
                analyze_moves = sorted(
                    [
                        Move(coords=(x, y), player=cn.next_player)
                        for x in range(board_size_x)
                        for y in range(board_size_y)
                        if (policy_grid is None and (x, y) not in stones) or policy_grid[y][x] >= 0
                    ],
                    key=lambda mv: -policy_grid[mv.coords[1]][mv.coords[0]],
                )
            else:
                analyze_moves = [
                    Move(coords=(x, y), player=cn.next_player)
                    for x in range(board_size_x)
                    for y in range(board_size_y)
                    if (x, y) not in stones
                ]
            visits = engine.config["fast_visits"]
            self.katrain.controls.set_status(i18n._("sweep analysis").format(visits=visits), STATUS_ANALYSIS)
            priority = PRIORITY_SWEEP
        elif mode in ["equalize", "alternative", "local"]:
            if not cn.analysis_complete and mode != "local":
                self.katrain.controls.set_status(i18n._("wait-before-extra-analysis"), STATUS_INFO, self.current_node)
                return
            if mode == "alternative":  # also do a quick update on current candidates so it doesn't look too weird
                self.katrain.controls.set_status(i18n._("alternative analysis"), STATUS_ANALYSIS)
                cn.analyze(engine, priority=PRIORITY_ALTERNATIVES, time_limit=False, find_alternatives="alternative")
                visits = engine.config["fast_visits"]
            else:  # equalize
                visits = max(d["visits"] for d in cn.analysis["moves"].values())
                self.katrain.controls.set_status(i18n._("equalizing analysis").format(visits=visits), STATUS_ANALYSIS)
            priority = PRIORITY_EQUALIZE
            analyze_moves = [Move.from_gtp(gtp, player=cn.next_player) for gtp, _ in cn.analysis["moves"].items()]
        else:
            raise ValueError("Invalid analysis mode")

        for move in analyze_moves:
            if cn.analysis["moves"].get(move.gtp(), {"visits": 0})["visits"] < visits:
                cn.analyze(
                    engine, priority=priority, visits=visits, refine_move=move, time_limit=False
                )  # explicitly requested so take as long as you need

    def selfplay(self, until_move, target_b_advantage=None):
        cn = self.current_node

        if target_b_advantage is not None:
            analysis_kwargs = {"visits": max(25, self.katrain.config("engine/fast_visits"))}
            engine_settings = {"wideRootNoise": 0.03}
        else:
            analysis_kwargs = engine_settings = {}

        def set_analysis(node, result):
            node.set_analysis(result)
            analyze_and_play(node)

        def request_analysis_for_node(node):
            self.engines[node.player].request_analysis(
                node,
                callback=lambda result, _partial: set_analysis(node, result),
                priority=PRIORITY_DEFAULT,
                analyze_fast=True,
                extra_settings=engine_settings,
                **analysis_kwargs,
            )

        def analyze_and_play(node):
            nonlocal cn, engine_settings
            candidates = node.candidate_moves
            if self.katrain.game is not self:
                return  # a new game happened
            ai_thoughts = "Move generated by AI self-play\n"
            if until_move != "end" and target_b_advantage is not None:  # setup pos
                if node.depth >= until_move or candidates[0]["move"] == "pass":
                    self.set_current_node(node)
                    return
                target_score = cn.score + (node.depth - cn.depth + 1) * (target_b_advantage - cn.score) / (
                    until_move - cn.depth
                )
                max_loss = 5
                stddev = min(3, 0.5 + (until_move - node.depth) * 0.15)
                ai_thoughts += f"Selecting moves aiming at score {target_score:.1f} +/- {stddev:.2f} with < {max_loss} points lost\n"
                if abs(node.score - target_score) < 3 * stddev:
                    weighted_cands = [
                        (
                            move,
                            math.exp(-0.5 * (abs(move["scoreLead"] - target_score) / stddev) ** 2)
                            * math.exp(-0.5 * (min(0, move["pointsLost"]) / max_loss) ** 2),
                        )
                        for i, move in enumerate(candidates)
                        if move["pointsLost"] < max_loss or i == 0
                    ]
                    move_info = weighted_selection_without_replacement(weighted_cands, 1)[0][0]
                    for move, wt in weighted_cands:
                        self.katrain.log(
                            f"{'* ' if move_info == move else '  '} {move['move']} {move['scoreLead']} {wt}",
                            OUTPUT_EXTRA_DEBUG,
                        )
                        ai_thoughts += f"Move option: {move['move']} score {move['scoreLead']:.2f} loss {move['pointsLost']:.2f} weight {wt:.3e}\n"
                else:  # we're a bit lost, far away from target, just push it closer
                    move_info = min(candidates, key=lambda move: abs(move["scoreLead"] - target_score))
                    self.katrain.log(
                        f"* Played {move_info['move']} {move_info['scoreLead']} because score deviation between current score {node.score} and target score {target_score} > {3*stddev}",
                        OUTPUT_EXTRA_DEBUG,
                    )
                    ai_thoughts += f"Move played to close difference between score {node.score:.1f} and target {target_score:.1f} quickly."

                self.katrain.log(
                    f"Self-play until {until_move} target {target_b_advantage}: {len(candidates)} candidates -> move {move_info['move']} score {move_info['scoreLead']} point loss {move_info['pointsLost']}",
                    OUTPUT_DEBUG,
                )
                move = Move.from_gtp(move_info["move"], player=node.next_player)
            elif candidates:  # just selfplay to end
                move = Move.from_gtp(candidates[0]["move"], player=node.next_player)
            else:  # 1 visit etc
                polmoves = node.policy_ranking
                move = polmoves[0][1] if polmoves else Move(None)
            if move.is_pass:
                if self.current_node == cn:
                    self.set_current_node(node)
                return
            new_node = GameNode(parent=node, move=move)
            new_node.ai_thoughts = ai_thoughts
            if until_move != "end" and target_b_advantage is not None:
                self.set_current_node(new_node)
                self.katrain.controls.set_status(
                    i18n._("setup game status message").format(move=new_node.depth, until_move=until_move),
                    STATUS_INFO,
                )
            else:
                if node != cn:
                    node.remove_shortcut()
                cn.add_shortcut(new_node)

            self.katrain.controls.move_tree.redraw_tree_trigger()
            request_analysis_for_node(new_node)

        request_analysis_for_node(cn)

    def analyze_undo(self, node):
        train_config = self.katrain.config("trainer")
        move = node.move
        if node != self.current_node or node.auto_undo is not None or not node.analysis_complete or not move:
            return
        points_lost = node.points_lost
        thresholds = train_config["eval_thresholds"]
        num_undo_prompts = train_config["num_undo_prompts"]
        i = 0
        while i < len(thresholds) and points_lost < thresholds[i]:
            i += 1
        num_undos = num_undo_prompts[i] if i < len(num_undo_prompts) else 0
        if num_undos == 0:
            undo = False
        elif num_undos < 1:  # probability
            undo = int(node.undo_threshold < num_undos) and len(node.parent.children) == 1
        else:
            undo = len(node.parent.children) <= num_undos

        node.auto_undo = undo
        if undo:
            self.undo(1)
            self.katrain.controls.set_status(
                i18n._("teaching undo message").format(move=move.gtp(), points_lost=points_lost), STATUS_TEACHING
            )
            self.katrain.update_state()
