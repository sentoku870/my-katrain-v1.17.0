import copy
import math
import os
import re
import threading
from collections.abc import Iterator
from datetime import datetime
from typing import Any

from katrain.core.constants import (
    OUTPUT_DEBUG,
    OUTPUT_EXTRA_DEBUG,
    OUTPUT_INFO,
    PLAYER_AI,
    PLAYER_HUMAN,
    PRIORITY_ALTERNATIVES,
    PRIORITY_DEFAULT,
    PRIORITY_EQUALIZE,
    PRIORITY_EXTRA_ANALYSIS,
    PRIORITY_GAME_ANALYSIS,
    PRIORITY_SWEEP,
    PROGRAM_NAME,
    SGF_INTERNAL_COMMENTS_MARKER,
    STATUS_ANALYSIS,
    STATUS_ERROR,
    STATUS_INFO,
    STATUS_TEACHING,
    AnalysisMode,
    parse_analysis_mode,
)
from katrain.core.engine import KataGoEngine
from katrain.core.game_node import GameNode
from katrain.core.lang import i18n, rank_label

# KarteGenerationError moved to reports/karte_report.py (PR #119)
# Re-export for backward compatibility
from katrain.core.reports.karte.models import KarteGenerationError
from katrain.core.sgf_parser import SGF, Move
from katrain.core.utils import var_to_grid, weighted_selection_without_replacement

from . import eval_metrics
from .eval_metrics import (
    EvalSnapshot,
    GameSummaryData,
    MistakeCategory,
    MoveEval,
    snapshot_from_game,
)


class IllegalMoveException(Exception):
    pass


class KaTrainSGF(SGF):
    _NODE_CLASS = GameNode  # type: ignore[assignment]


class BaseGame:
    """Represents a game of go, including an implementation of capture rules."""

    DEFAULT_PROPERTIES = {"GM": 1, "FF": 4}

    # Class-level type annotations for instance variables
    katrain: Any
    root: GameNode
    current_node: GameNode
    game_id: str
    sgf_filename: str | None
    insert_mode: bool
    external_game: bool
    main_time_used: int
    board: list[list[int]]
    chains: list[list[Move]]
    prisoners: list[Move]
    last_capture: list[Move]

    def __init__(
        self,
        katrain: Any,
        move_tree: GameNode | None = None,
        game_properties: dict[str, Any | None] | None = None,
        sgf_filename: str | None = None,
        bypass_config: bool = False,  # TODO: refactor?
    ) -> None:
        self.katrain = katrain
        self._lock = threading.RLock()  # RLock for set_current_node → _calculate_groups reentry
        self.game_id = datetime.strftime(datetime.now(), "%Y-%m-%d %H %M %S")
        self.sgf_filename = sgf_filename

        self.insert_mode = False
        self.external_game = False  # not generated by katrain at some point

        if move_tree:
            self.root = move_tree
            self.external_game = PROGRAM_NAME not in self.root.get_property("AP", "")
            handicap = int(self.root.handicap)
            num_starting_moves_black = 0
            node: GameNode = self.root
            while node.children:
                child = node.children[0]
                assert isinstance(child, GameNode)
                node = child
                if node.player == "B":
                    num_starting_moves_black += 1
                else:
                    break

            if (
                handicap >= 2
                and not self.root.placements
                and num_starting_moves_black != handicap
                and not (self.root.children and self.root.children[0].placements)
            ):  # not really according to sgf, and not sure if still needed, last clause for fox
                self.root.place_handicap_stones(handicap)
        else:
            default_properties = {**Game.DEFAULT_PROPERTIES, "DT": self.game_id}
            if not bypass_config:
                default_properties.update(
                    {
                        "SZ": katrain.config("game/size"),
                        "KM": katrain.config("game/komi"),
                        "RU": katrain.config("game/rules"),
                    }
                )
            merged_props: dict[str, list[Any]] = {k: [v] for k, v in default_properties.items()}
            if game_properties:
                for k, v in game_properties.items():
                    merged_props[k] = [v] if not isinstance(v, list) else v
            self.root = GameNode(properties=merged_props)
            handicap = katrain.config("game/handicap")
            if not bypass_config and handicap:
                self.root.place_handicap_stones(handicap)

        if not self.root.get_property("RU"):  # if rules missing in sgf, inherit current
            self.root.set_property("RU", katrain.config("game/rules"))

        self.set_current_node(self.root)
        self.main_time_used = 0

        # restore shortcuts
        all_nodes = [n for n in self.root.nodes_in_tree if isinstance(n, GameNode)]
        shortcut_id_to_node: dict[Any, GameNode] = {node.get_property("KTSID", None): node for node in all_nodes}
        for node in all_nodes:
            shortcut_id = node.get_property("KTSF", None)
            if shortcut_id and shortcut_id in shortcut_id_to_node:
                shortcut_id_to_node[shortcut_id].add_shortcut(node)

    # -- move tree functions --
    def _init_state(self) -> None:
        board_size_x, board_size_y = self.board_size
        self.board = [[-1 for _x in range(board_size_x)] for _y in range(board_size_y)]  # type: list[list[int]]  #  board pos -> chain id
        self.chains = []  # type: list[list[Move]]  #   chain id -> chain
        self.prisoners = []  # type: list[Move]
        self.last_capture = []  # type: list[Move]

    def _calculate_groups(self) -> None:
        with self._lock:
            self._init_state()
            try:
                for node in self.current_node.nodes_from_root:
                    for m in node.move_with_placements:
                        self._validate_move_and_update_chains(
                            m, True
                        )  # ignore ko since we didn't know if it was forced
                    if node.clear_placements:  # handle AE by playing all moves left from empty board
                        clear_coords = {c.coords for c in node.clear_placements}
                        stones = [m for c in self.chains for m in c if m.coords not in clear_coords]
                        self._init_state()
                        for m in stones:
                            self._validate_move_and_update_chains(m, True)
            except IllegalMoveException as e:
                raise Exception(f"Unexpected illegal move ({str(e)})")

    def _validate_move_and_update_chains(self, move: Move, ignore_ko: bool) -> None:
        board_size_x, board_size_y = self.board_size

        def neighbours(moves: list[Move]) -> set[int]:
            return {
                self.board[m.coords[1] + dy][m.coords[0] + dx]
                for m in moves
                if m.coords is not None
                for dy, dx in [(-1, 0), (1, 0), (0, -1), (0, 1)]
                if 0 <= m.coords[0] + dx < board_size_x and 0 <= m.coords[1] + dy < board_size_y
            }

        ko_or_snapback = len(self.last_capture) == 1 and self.last_capture[0] == move
        self.last_capture = []

        if move.is_pass:
            return

        assert move.coords is not None
        if self.board[move.coords[1]][move.coords[0]] != -1:
            raise IllegalMoveException("Space occupied")

        # merge chains connected by this move, or create a new one
        nb_chains = list({c for c in neighbours([move]) if c >= 0 and self.chains[c][0].player == move.player})
        if nb_chains:
            this_chain = nb_chains[0]
            self.board = [[nb_chains[0] if sq in nb_chains else sq for sq in line] for line in self.board]
            for oc in nb_chains[1:]:
                self.chains[nb_chains[0]] += self.chains[oc]
                self.chains[oc] = []
            self.chains[nb_chains[0]].append(move)
        else:
            this_chain = len(self.chains)
            self.chains.append([move])
        self.board[move.coords[1]][move.coords[0]] = this_chain

        # check captures
        opp_nb_chains = {c for c in neighbours([move]) if c >= 0 and self.chains[c][0].player != move.player}
        for c in opp_nb_chains:
            if -1 not in neighbours(self.chains[c]):  # no liberties
                self.last_capture += self.chains[c]
                for om in self.chains[c]:
                    assert om.coords is not None  # stones on board always have coords
                    self.board[om.coords[1]][om.coords[0]] = -1
                self.chains[c] = []
        if ko_or_snapback and len(self.last_capture) == 1 and not ignore_ko:
            raise IllegalMoveException("Ko")
        self.prisoners += self.last_capture

        # suicide: check rules and throw exception if needed
        if -1 not in neighbours(self.chains[this_chain]):
            rules = self.rules
            if len(self.chains[this_chain]) == 1:  # even in new zealand rules, single stone suicide is not allowed
                raise IllegalMoveException("Single stone suicide")
            elif (isinstance(rules, str) and rules in ["tromp-taylor", "new zealand"]) or (
                isinstance(rules, dict) and rules.get("suicide", False)
            ):
                self.last_capture += self.chains[this_chain]
                for om in self.chains[this_chain]:
                    assert om.coords is not None  # stones on board always have coords
                    self.board[om.coords[1]][om.coords[0]] = -1
                self.chains[this_chain] = []
                self.prisoners += self.last_capture
            else:  # suicide not allowed by rules
                raise IllegalMoveException("Suicide")

    # Play a Move from the current position, raise IllegalMoveException if invalid.
    def play(self, move: Move, ignore_ko: bool = False) -> GameNode:
        board_size_x, board_size_y = self.board_size
        if not move.is_pass:
            assert move.coords is not None
            if not (0 <= move.coords[0] < board_size_x and 0 <= move.coords[1] < board_size_y):
                raise IllegalMoveException(f"Move {move} outside of board coordinates")
        try:
            self._validate_move_and_update_chains(move, ignore_ko)
        except IllegalMoveException:
            self._calculate_groups()
            raise
        with self._lock:
            played_node = self.current_node.play(move)
            assert isinstance(played_node, GameNode)
            self.current_node = played_node
        return played_node

    # Insert a list of moves from root, often just adding one.
    def sync_branch(self, moves: list[Move]) -> GameNode:
        node: GameNode = self.root
        with self._lock:
            for move in moves:
                next_node = node.play(move)
                assert isinstance(next_node, GameNode)
                node = next_node
        return node

    def set_current_node(self, node: GameNode) -> None:
        self.current_node = node
        self._calculate_groups()

    def undo(self, n_times: int | str = 1, stop_on_mistake: Any = None) -> None:
        """Undo moves with thread-safe state update.

        Lock scope: state mutation only (current_node, _calculate_groups).
        UI updates are triggered separately by caller via update_state().

        Args:
            n_times: Number of moves to undo, or "branch"/"main-branch" for special modes.
            stop_on_mistake: Stop on mistake threshold (optional).
        """
        with self._lock:
            break_on_branch = False
            cn: GameNode = self.current_node
            break_on_main_branch = False
            last_branching_node = cn
            effective_n_times: int
            if n_times == "branch":
                effective_n_times = 9999
                break_on_branch = True
            elif n_times == "main-branch":
                effective_n_times = 9999
                break_on_main_branch = True
            else:
                assert isinstance(n_times, int)
                effective_n_times = n_times
            for _move in range(effective_n_times):
                if (
                    stop_on_mistake is not None
                    and cn.points_lost is not None
                    and cn.points_lost >= stop_on_mistake
                    and self.katrain.players_info[cn.player].player_type != PLAYER_AI
                ):
                    parent = cn.parent
                    if isinstance(parent, GameNode):
                        self.set_current_node(parent)
                    return
                previous_cn = cn
                if cn.shortcut_from:
                    cn = cn.shortcut_from
                elif not cn.is_root:
                    parent = cn.parent
                    if isinstance(parent, GameNode):
                        cn = parent
                    else:
                        break  # root or invalid parent
                else:
                    break  # root
                if break_on_branch and len(cn.children) > 1:
                    break
                elif break_on_main_branch and cn.ordered_children[0] != previous_cn:  # implies > 1 child
                    last_branching_node = cn
            if break_on_main_branch:
                cn = last_branching_node
            if cn is not self.current_node:
                self.set_current_node(cn)

    def redo(self, n_times: int = 1, stop_on_mistake: float | None = None) -> None:
        """Redo moves with thread-safe state update.

        Lock scope: state mutation only (current_node, _calculate_groups).
        UI updates are triggered separately by caller via update_state().
        """
        with self._lock:
            cn: GameNode = self.current_node
            for move in range(n_times):
                if cn.children:
                    child_node = cn.ordered_children[0]
                    shortcut_to = [
                        m for m, v in cn.shortcuts_to if child_node == v
                    ]  # are we about to go to a shortcut node?
                    if shortcut_to:
                        child_node = shortcut_to[0]
                    assert isinstance(child_node, GameNode)
                    cn = child_node
                if (
                    move > 0
                    and stop_on_mistake is not None
                    and cn.points_lost is not None
                    and cn.points_lost >= stop_on_mistake
                    and self.katrain.players_info[cn.player].player_type != PLAYER_AI
                ):
                    parent = cn.parent
                    if isinstance(parent, GameNode):
                        self.set_current_node(parent)
                    return
            if stop_on_mistake is None:
                self.set_current_node(cn)

    @property
    def komi(self) -> float:
        return self.root.komi

    @property
    def board_size(self) -> tuple[int, int]:
        return self.root.board_size

    @property
    def stones(self) -> list[Move]:
        with self._lock:
            return sum(self.chains, [])

    @property
    def end_result(self) -> str | None:
        if self.current_node.end_state:
            return str(self.current_node.end_state)
        if self.current_node.parent and self.current_node.is_pass and self.current_node.parent.is_pass:
            return self.manual_score or i18n._("board-game-end")
        return None

    @property
    def prisoner_count(self) -> dict[str, int]:
        # returns prisoners that are of a certain colour as {B: black stones captures, W: white stones captures}
        return {player: sum([m.player == player for m in self.prisoners]) for player in Move.PLAYERS}

    @property
    def rules(self) -> Any:
        return KataGoEngine.get_rules(self.root.ruleset)

    @property
    def manual_score(self) -> str | None:
        rules = self.rules
        parent = self.current_node.parent
        parent_ownership: list[float | None] | None = None
        if isinstance(parent, GameNode):
            parent_ownership = parent.ownership
        if (
            not self.current_node.ownership
            or str(rules).lower() not in ["jp", "japanese"]
            or not parent
            or not parent_ownership
        ):
            if not self.current_node.score:
                return None
            score = self.current_node.score
            assert score is not None
            formatted = self.current_node.format_score(round(2 * score) / 2)
            return formatted + "?" if formatted else None
        board_size_x, board_size_y = self.board_size
        current_ownership = self.current_node.ownership
        assert current_ownership is not None
        mean_ownership: list[float] = []
        for c, p in zip(current_ownership, parent_ownership, strict=False):
            if c is not None and p is not None:
                mean_ownership.append((c + p) / 2)
        ownership_grid = var_to_grid(mean_ownership, (board_size_x, board_size_y))
        stones = {m.coords: m.player for m in self.stones}
        lo_threshold = 0.15
        hi_threshold = 0.85
        max_unknown = 10
        max_dame = 4 * (board_size_x + board_size_y)

        def japanese_score_square(square: tuple[int, int], owner: float) -> float:
            player = stones.get(square)
            if (
                (player == "B" and owner > hi_threshold)
                or (player == "W" and owner < -hi_threshold)
                or abs(owner) < lo_threshold
            ):
                return 0  # dame or own stones
            if player is None and abs(owner) >= hi_threshold:
                return round(owner)  # surrounded empty intersection
            if (player == "B" and owner < -hi_threshold) or (player == "W" and owner > hi_threshold):
                return 2 * round(owner)  # captured stone
            return math.nan  # unknown!

        scored_squares = [
            japanese_score_square((x, y), ownership_grid[y][x])
            for y in range(board_size_y)
            for x in range(board_size_x)
        ]
        num_sq = {t: sum([s == t for s in scored_squares]) for t in [-2, -1, 0, 1, 2]}
        num_unkn = sum(math.isnan(s) for s in scored_squares)
        prisoners = self.prisoner_count
        score = sum([t * n for t, n in num_sq.items()]) + prisoners["W"] - prisoners["B"] - self.komi
        self.katrain.log(
            f"Manual Scoring: {num_sq} score by square with {num_unkn} unknown, {prisoners} captures, and {self.komi} komi -> score = {score}",
            OUTPUT_DEBUG,
        )
        if num_unkn > max_unknown or (num_sq[0] - len(stones)) > max_dame:
            return None
        return self.current_node.format_score(score)

    def __repr__(self) -> str:
        return (
            "\n".join("".join(self.chains[c][0].player if c >= 0 else "-" for c in line) for line in self.board)
            + f"\ncaptures: {self.prisoner_count}"
        )

    def update_root_properties(self) -> None:
        def player_name(player_info: Any) -> str:
            if player_info.name and player_info.player_type == PLAYER_HUMAN:
                return str(player_info.name)
            else:
                return f"{i18n._(player_info.player_type)} ({i18n._(player_info.player_subtype)}){SGF_INTERNAL_COMMENTS_MARKER}"

        root_properties = self.root.properties
        x_properties: dict[str, Any] = {}
        for bw in "BW":
            if not self.external_game:
                x_properties["P" + bw] = player_name(self.katrain.players_info[bw])
                player_info = self.katrain.players_info[bw]
                if player_info.player_type == PLAYER_AI:
                    x_properties[bw + "R"] = rank_label(player_info.calculated_rank)
        if "+" in str(self.end_result):
            x_properties["RE"] = self.end_result
        self.root.properties = {**root_properties, **{k: [v] for k, v in x_properties.items()}}

    def generate_filename(self) -> str:
        self.update_root_properties()
        player_names = {
            bw: re.sub(r"[\u200b\u3164'<>:\"/\\|?*]", "", self.root.get_property("P" + bw, bw)) for bw in "BW"
        }
        base_game_name = f"{PROGRAM_NAME}_{player_names['B']} vs {player_names['W']}"
        return f"{base_game_name} {self.game_id}.sgf"

    def write_sgf(self, filename: str, trainer_config: dict[str, Any | None] | None = None) -> str:
        if trainer_config is None:
            trainer_config = self.katrain.config("trainer", {})
        save_feedback = trainer_config.get("save_feedback", False)
        eval_thresholds = trainer_config["eval_thresholds"]
        save_analysis = trainer_config.get("save_analysis", False)
        save_marks = trainer_config.get("save_marks", False)
        self.update_root_properties()
        show_dots_for = {
            bw: trainer_config.get("eval_show_ai", True) or self.katrain.players_info[bw].human for bw in "BW"
        }
        sgf = self.root.sgf(
            save_comments_player=show_dots_for,
            save_comments_class=save_feedback,
            eval_thresholds=eval_thresholds,
            save_analysis=save_analysis,
            save_marks=save_marks,
        )
        self.sgf_filename = filename
        os.makedirs(os.path.dirname(filename), exist_ok=True)
        with open(filename, "w", encoding="utf-8") as f:
            f.write(sgf)
        return i18n._("sgf written").format(file_name=filename)


class Game(BaseGame):
    """Extensions related to analysis etc."""

    # Class-level type annotations for instance variables
    engines: dict[str, KataGoEngine]
    insert_after: GameNode | None
    region_of_interest: list[int | None] | None

    def __init__(
        self,
        katrain: Any,
        engine: dict[str, Any] | Any,
        move_tree: GameNode | None = None,
        analyze_fast: bool = False,
        game_properties: dict[str, Any | None] | None = None,
        sgf_filename: str | None = None,
    ) -> None:
        super().__init__(
            katrain=katrain, move_tree=move_tree, game_properties=game_properties, sgf_filename=sgf_filename
        )
        if not isinstance(engine, dict):
            engine = {"B": engine, "W": engine}
        self.engines = engine

        self.insert_mode = False
        self.insert_after = None
        self.region_of_interest = None

        # Stop any existing pondering before starting full-game analysis
        katrain.pondering = False
        for e in set(self.engines.values()):
            e.stop_pondering()

        threading.Thread(
            target=lambda: self.analyze_all_nodes(analyze_fast=analyze_fast, even_if_present=True),
            daemon=True,
        ).start()  # return faster, but bypass Kivy Clock

    def analyze_all_nodes(
        self,
        priority: int = PRIORITY_GAME_ANALYSIS,
        analyze_fast: bool = False,
        even_if_present: bool = True,
    ) -> None:
        """Analyze all nodes with throttling to avoid overwhelming the engine.

        Throttling logic:
        - Before each request, check if engine has capacity (headroom=10)
        - If at capacity, wait 0.1s and retry (up to 50 attempts = 5s max wait)
        - If still no capacity after waiting, skip the node to avoid blocking forever
        """
        import time

        for sgf_node in self.root.nodes_in_tree:
            if not isinstance(sgf_node, GameNode):
                continue
            node: GameNode = sgf_node
            # forced, or not present, or something went wrong in loading
            if even_if_present or not node.analysis_from_sgf or not node.load_analysis():
                # Throttle: wait for engine capacity before sending request
                engine = self.engines[node.next_player]
                max_wait_attempts = 50  # 50 * 0.1s = 5s max wait per node
                for _ in range(max_wait_attempts):
                    if engine.has_query_capacity(headroom=10):
                        break
                    time.sleep(0.1)
                else:
                    # Timeout waiting for capacity - log and skip this node
                    self.katrain.log(
                        f"Skipping analysis for move {node.move_number}: engine at capacity",
                        OUTPUT_DEBUG,
                    )
                    continue

                node.clear_analysis()
                node.analyze(
                    engine,
                    priority=priority,
                    analyze_fast=analyze_fast,
                )

    def build_eval_snapshot(self) -> EvalSnapshot:
        """
        現在の Game（メイン分岐）から EvalSnapshot を生成するヘルパー。

        Phase 2 以降で UI や教育機能から共通で呼び出す入口として使う。
        """
        return snapshot_from_game(self)


    def log_mistake_summary_for_debug(self) -> None:
        """
        対局全体のミス分類サマリをコンソールに出力するデバッグ用ユーティリティ。
        - Phase3 のしきい値設定・挙動確認に使用する。
        """
        snapshot = self.build_eval_snapshot()

        counts: dict[MistakeCategory, int] = {}
        for m in snapshot.moves:
            # None の場合は GOOD 扱いに寄せる
            cat = m.mistake_category or MistakeCategory.GOOD
            counts[cat] = counts.get(cat, 0) + 1

        total_moves = len(snapshot.moves)

        print("=== Mistake summary (debug) ===")
        print(f"Total moves: {total_moves}")
        # カテゴリ順に固定したい場合は MistakeCategory の順で回す
        for cat in MistakeCategory:
            n = counts.get(cat, 0)
            label = cat.value  # "BLUNDER" 等
            print(f"{label:10s}: {n:3d}")

    # ------------------------------------------------------------------
    # 重要局面レポート / YoseAnalyzer 連携用のヘルパー
    # ------------------------------------------------------------------

    def _find_node_by_move_number(self, move_number: int) -> GameNode | None:
        """メインブランチの手数でノードを検索

        Args:
            move_number: 手数（1-indexed）

        Returns:
            GameNode | None: 見つかったノード、または None
        """
        for node in eval_metrics.iter_main_branch_nodes(self):
            node_move_no = len(node.nodes_from_root) - 1
            if node_move_no == move_number:
                return node
        return None

    def get_important_move_evals(
        self,
        *,
        level: str = eval_metrics.DEFAULT_IMPORTANT_MOVE_LEVEL,
        compute_reason_tags: bool = True,
    ) -> list[MoveEval]:
        """
        現在の対局（メイン分岐）について、
        重要度スコアの大きい手 (= 重要局面候補) を MoveEval のリストとして返す。

        - EvalSnapshot + pick_important_moves をまとめた入口。
        - 今後 YoseAnalyzer からもここを呼ぶ想定。
        """
        snapshot = self.build_eval_snapshot()

        # 手が 1 手もない（起動直後の空局面など）は空リスト
        if not snapshot.moves:
            return []

        important_moves = eval_metrics.pick_important_moves(
            snapshot,
            level=level,
            recompute=True,
        )

        # Phase 5: 重要局面のみ理由タグを計算
        if compute_reason_tags:
            from katrain.core import board_analysis

            unknown_count = 0
            for move_eval in important_moves:
                try:
                    # 対応するノードを検索
                    node = self._find_node_by_move_number(move_eval.move_number)
                    if node is None:
                        move_eval.reason_tags = ["unknown"]
                        unknown_count += 1
                        continue

                    # このノードで盤面を分析
                    board_state = board_analysis.analyze_board_at_node(self, node)

                    # 候補手を取得
                    candidates = node.candidate_moves if hasattr(node, "candidate_moves") else []

                    # タグを計算（Phase 17: skill_preset を渡す）
                    move_eval.reason_tags = board_analysis.get_reason_tags_for_move(
                        board_state, move_eval, node, candidates, skill_preset=level
                    )

                    # タグが空の場合は "unknown" を設定
                    if not move_eval.reason_tags:
                        move_eval.reason_tags = ["unknown"]
                        unknown_count += 1
                except Exception as e:
                    # 失敗時は優雅に処理: 分析失敗時は "unknown" を設定
                    self.katrain.log(
                        f"Failed to compute reason tags for move #{move_eval.move_number}: {e}", OUTPUT_DEBUG
                    )
                    move_eval.reason_tags = ["unknown"]
                    unknown_count += 1

            # unknown_count をログに出力（カバレッジ確認用）
            if unknown_count > 0 and important_moves:
                self.katrain.log(
                    f"[ReasonTags] {unknown_count}/{len(important_moves)} moves have unknown reason tags", OUTPUT_DEBUG
                )

        return important_moves

    def build_important_moves_report(
        self,
        *,
        level: str = eval_metrics.DEFAULT_IMPORTANT_MOVE_LEVEL,
        max_lines: int | None = None,
    ) -> str:
        """
        現在の対局（メイン分岐）について、
        「重要度スコアが大きい手」をテキストレポートとして返す。

        - 手数 / 手番 / 着手 / 損失(目) / ミス分類 / 難易度 / 形勢差Δ / 勝率Δ
        - eval_metrics.pick_important_moves の結果に基づく

        Args:
            level:
                重要局面検出のレベル。
                - "easy"   : ゆるめに拾う
                - "normal" : 標準
                - "strict" : より厳しめに大きな局面だけ
            max_lines:
                レポートの最大行数（None の場合は全件）

        Note:
            PR #120: Moved implementation to katrain.core.reports.important_moves_report
        """
        from katrain.core.reports import important_moves_report

        important_moves = self.get_important_move_evals(level=level)
        return important_moves_report.build_important_moves_report(
            important_moves,
            level=level,
            max_lines=max_lines,
        )

    def build_karte_report(
        self,
        level: str = eval_metrics.DEFAULT_IMPORTANT_MOVE_LEVEL,
        player_filter: str | None = None,
        raise_on_error: bool = False,
        skill_preset: str = eval_metrics.DEFAULT_SKILL_PRESET,
        target_visits: int | None = None,
    ) -> str:
        """Build a compact, markdown-friendly report for the current game.

        Args:
            level: Important move level setting
            player_filter: Filter by player ("B", "W", or None for both)
                          Can also be a username string to match against player names
            raise_on_error: If True, raise KarteGenerationError on failure.
                           If False (default), return error markdown instead.
            skill_preset: Skill preset for strictness ("auto" or one of SKILL_PRESETS keys)
            target_visits: Target visits for effective reliability threshold calculation.
                If None, uses the hardcoded RELIABILITY_VISITS_THRESHOLD (200).

        Returns:
            Markdown-formatted karte report.
            On error with raise_on_error=False, returns a report with ERROR section.

        Raises:
            KarteGenerationError: If raise_on_error=True and generation fails.

        Note:
            PR #119: Moved implementation to katrain.core.reports.karte_report
        """
        from katrain.core.reports import karte_report

        return karte_report.build_karte_report(
            self,
            level=level,
            player_filter=player_filter,
            raise_on_error=raise_on_error,
            skill_preset=skill_preset,
            target_visits=target_visits,
        )

    @staticmethod
    def build_summary_report(game_data_list: list[GameSummaryData], focus_player: str | None = None) -> str:
        """
        複数局から統計まとめを生成（Phase 6）

        Note: PR #116 で katrain.core.reports.summary_report に移動。
        後方互換性のため委譲メソッドを残す。

        Args:
            game_data_list: 各対局のデータリスト
            focus_player: 集計対象プレイヤー名（Noneなら全プレイヤー）

        Returns:
            Markdown形式のまとめレポート
        """
        from katrain.core.reports import summary_report

        return summary_report.build_summary_report(game_data_list, focus_player)

    def log_important_moves_for_debug(
        self,
        *,
        level: str = "normal",
    ) -> None:
        """
        現在の対局（メイン分岐）について、
        「重要度スコアが大きい手」をログに出力するデバッグ用ヘルパー。

        - UI からはまだ呼ばない想定。
        - Phase 2 以降の機能実装時に挙動確認用として利用する。

        Args:
            level: 重要局面検出のレベル ("easy" / "normal" / "strict")
        """
        important_moves = self.get_important_move_evals(level=level)

        if not important_moves:
            settings = eval_metrics.IMPORTANT_MOVE_SETTINGS_BY_LEVEL.get(
                level,
                eval_metrics.IMPORTANT_MOVE_SETTINGS_BY_LEVEL[eval_metrics.DEFAULT_IMPORTANT_MOVE_LEVEL],
            )
            self.katrain.log(
                f"[Eval] No moves with importance > {settings.importance_threshold}",
                OUTPUT_INFO,
            )
            return

        # ヘッダ行
        settings = eval_metrics.IMPORTANT_MOVE_SETTINGS_BY_LEVEL.get(
            level,
            eval_metrics.IMPORTANT_MOVE_SETTINGS_BY_LEVEL[eval_metrics.DEFAULT_IMPORTANT_MOVE_LEVEL],
        )
        self.katrain.log(
            f"[Eval] Important moves (level={level}, "
            f"threshold={settings.importance_threshold}, max_moves={settings.max_moves})",
            OUTPUT_INFO,
        )

        # 各手を 1 行ずつログ出力
        for m in important_moves:
            self.katrain.log(
                (
                    "[Eval] move #{num} {player} {gtp} "
                    "score_before={sb} score_after={sa} "
                    "delta_score={ds} points_lost={pl} "
                    "importance={imp}"
                ).format(
                    num=m.move_number,
                    player=m.player or "-",
                    gtp=m.gtp or "-",
                    sb=None if m.score_before is None else f"{m.score_before:.2f}",
                    sa=None if m.score_after is None else f"{m.score_after:.2f}",
                    ds=None if m.delta_score is None else f"{m.delta_score:.2f}",
                    pl=None if m.points_lost is None else f"{m.points_lost:.2f}",
                    imp=None if m.importance_score is None else f"{m.importance_score:.2f}",
                ),
                OUTPUT_INFO,
            )

    # ------------------------------------------------------------------
    # 重要局面ナビ用のヘルパー
    # ------------------------------------------------------------------

    def _iter_main_branch_nodes(self) -> "Iterator[GameNode]":
        """
        ルートからメイン分岐（ordered_children[0] を辿った一本の線）
        上のノードだけを順に返す。
        """
        node: GameNode = self.root
        while node.children:
            child = node.ordered_children[0]
            assert isinstance(child, GameNode)
            node = child
            yield node

    def get_main_branch_node_before_move(self, move_number: int) -> GameNode | None:
        """
        メイン分岐上で指定手数の直前局面を返す（なければ None）。
        move_number が 1 以下なら root を返す。
        """
        if move_number <= 1:
            return self.root

        target = move_number - 1
        for node in eval_metrics.iter_main_branch_nodes(self):
            current_move_no = len(node.nodes_from_root) - 1
            if current_move_no == target:
                return node
            if current_move_no > target:
                break
        return None

    def _compute_important_moves(self, max_moves: int = 20) -> list[tuple[int, float, GameNode]]:
        """
        メイン分岐上のノードから「重要そうな手」を抽出して返す。

        戻り値: [(手数, 重要度スコア, GameNode), ...]  を
                手数昇順に並べたリスト。

        Phase 70: 単一パスアルゴリズムに最適化。
        重複ループを解消し、heapq.nlargest で上位 max_moves 件を効率的に抽出。
        """
        import heapq

        IMPORTANCE_THRESHOLD = 0.5  # 小さい変化をノイズとして除外

        # 単一パスで全ノードを収集
        all_nodes: list[tuple[int, float, GameNode]] = []
        prev_score: float | None = None

        for node in self._iter_main_branch_nodes():
            # 解析が終わっていない手はスキップ
            if not node.analysis_complete or node.score is None:
                continue

            move_no = len(node.nodes_from_root) - 1
            points_lost = node.points_lost or 0.0
            delta_score = 0.0 if prev_score is None else abs(node.score - prev_score)

            # 「ミス or 大きな形勢変化」を重要度とする
            importance = max(points_lost, delta_score)

            all_nodes.append((move_no, importance, node))
            prev_score = node.score

        # 閾値を超える候補を抽出、なければ全ノードをフォールバック
        candidates = [(m, i, n) for m, i, n in all_nodes if i > IMPORTANCE_THRESHOLD]
        if not candidates:
            candidates = all_nodes

        # 重要度の大きい順に上位 max_moves 件を抽出
        top = heapq.nlargest(max_moves, candidates, key=lambda t: t[1])

        # ナビゲーションで扱いやすいように、手数順に並べ直して返す
        top.sort(key=lambda t: t[0])
        return top

    def get_important_move_numbers(self, max_moves: int = 20) -> list[int]:
        """
        「重要局面」と判定された手数のリストだけを返す。
        ScoreGraph などから呼ぶことを想定。
        """
        important = self._compute_important_moves(max_moves=max_moves)
        return [move_no for move_no, _importance, _node in important]

    def get_next_important_node(self, max_moves: int = 20) -> GameNode | None:
        """
        現在の手より「後ろにある」重要局面ノードを返す。
        なければ None。
        """
        important = self._compute_important_moves(max_moves=max_moves)
        if not important:
            return None

        current_move_no = len(self.current_node.nodes_from_root) - 1

        for move_no, _importance, node in important:
            if move_no > current_move_no:
                return node

        # すべて現在手より前なら、今回はジャンプしない仕様にしておく
        return None

    def get_prev_important_node(self, max_moves: int = 20) -> GameNode | None:
        """
        現在の手より「前にある」重要局面ノードを返す。
        なければ None。
        """
        important = self._compute_important_moves(max_moves=max_moves)
        if not important:
            return None

        current_move_no = len(self.current_node.nodes_from_root) - 1

        prev_node: GameNode | None = None
        for move_no, _importance, node in important:
            if move_no >= current_move_no:
                break
            prev_node = node

        return prev_node

    def jump_to_next_important_move(self, max_moves: int = 20) -> GameNode | None:
        """
        次の重要局面にジャンプする。
        実際に current_node を変更したノードを返す。なければ None。
        """
        node = self.get_next_important_node(max_moves=max_moves)
        if node is not None:
            self.set_current_node(node)
        return node

    def jump_to_prev_important_move(self, max_moves: int = 20) -> GameNode | None:
        """
        前の重要局面にジャンプする。
        実際に current_node を変更したノードを返す。なければ None。
        """
        node = self.get_prev_important_node(max_moves=max_moves)
        if node is not None:
            self.set_current_node(node)
        return node

    def set_current_node(self, node: GameNode) -> None:
        if self.insert_mode:
            self.katrain.controls.set_status(i18n._("finish inserting before navigating"), STATUS_ERROR)
            return
        super().set_current_node(node)

    def undo(self, n_times: int | str = 1, stop_on_mistake: Any = None) -> None:
        """Undo with insert-mode handling. Thread-safe via RLock."""
        with self._lock:
            if self.insert_mode:  # in insert mode, undo = delete
                cn = self.current_node
                if self.insert_after is not None and n_times == 1 and cn not in self.insert_after.nodes_from_root:
                    parent = cn.parent
                    if parent is not None:
                        parent.children = [c for c in parent.children if c != cn]
                        if isinstance(parent, GameNode):
                            self.current_node = parent
                        self._calculate_groups()
                return
            super().undo(n_times=n_times, stop_on_mistake=stop_on_mistake)

    def reset_current_analysis(self) -> None:
        cn = self.current_node
        engine = self.engines[cn.next_player]
        engine.terminate_queries(cn)
        cn.clear_analysis()
        cn.analyze(engine)

    def redo(self, n_times: int = 1, stop_on_mistake: float | None = None) -> None:
        if self.insert_mode:
            return
        super().redo(n_times=n_times, stop_on_mistake=stop_on_mistake)

    def set_insert_mode(self, mode: bool | str) -> None:
        effective_mode: bool
        if mode == "toggle":
            effective_mode = not self.insert_mode
        else:
            assert isinstance(mode, bool)
            effective_mode = mode
        if effective_mode == self.insert_mode:
            return
        self.insert_mode = effective_mode
        if effective_mode:
            children = self.current_node.ordered_children
            if not children:
                self.insert_mode = False
            else:
                child = self.current_node.ordered_children[0]
                assert isinstance(child, GameNode)
                self.insert_after = child
                self.katrain.controls.set_status(i18n._("starting insert mode"), STATUS_INFO)
        else:
            if self.insert_after is None:
                return
            copy_from_node: GameNode = self.insert_after
            copy_to_node: GameNode = self.current_node
            num_copied = 0
            insert_parent = self.insert_after.parent
            if copy_to_node != insert_parent:
                assert insert_parent is not None
                above_insertion_root = insert_parent.nodes_from_root
                already_inserted_moves = [
                    n.move for n in copy_to_node.nodes_from_root if n not in above_insertion_root and n.move
                ]
                try:
                    while True:
                        for m in copy_from_node.move_with_placements:
                            if m not in already_inserted_moves:
                                self._validate_move_and_update_chains(m, True)
                                # this inserts
                                copy_to_node = GameNode(
                                    parent=copy_to_node, properties=copy.deepcopy(copy_from_node.properties)
                                )
                                num_copied += 1
                        if not copy_from_node.children:
                            break
                        next_child = copy_from_node.ordered_children[0]
                        assert isinstance(next_child, GameNode)
                        copy_from_node = next_child
                except IllegalMoveException:
                    pass  # illegal move = stop
                self._calculate_groups()  # recalculate groups
                self.katrain.controls.set_status(
                    i18n._("ending insert mode").format(num_copied=num_copied), STATUS_INFO
                )
                self.analyze_all_nodes(analyze_fast=True, even_if_present=False)
            else:
                self.katrain.controls.set_status("", STATUS_INFO)
        self.katrain.controls.move_tree.insert_node = self.insert_after if self.insert_mode else None
        self.katrain.controls.move_tree.redraw()
        self.katrain.update_state(redraw_board=True)

    # Play a Move from the current position, raise IllegalMoveException if invalid.
    def play(self, move: Move, ignore_ko: bool = False, analyze: bool = True) -> GameNode:
        played_node = super().play(move, ignore_ko)
        if analyze:
            if self.region_of_interest:
                played_node.analyze(self.engines[played_node.next_player], analyze_fast=True)
                played_node.analyze(self.engines[played_node.next_player], region_of_interest=self.region_of_interest)
            else:
                played_node.analyze(self.engines[played_node.next_player])
        return played_node

    def set_region_of_interest(self, region_of_interest: tuple[int, int, int, int]) -> None:
        x1, x2, y1, y2 = region_of_interest
        xmin, xmax = min(x1, x2), max(x1, x2)
        ymin, ymax = min(y1, y2), max(y1, y2)
        szx, szy = self.board_size
        if not (xmin == xmax and ymin == ymax) and not (xmax - xmin + 1 >= szx and ymax - ymin + 1 >= szy):
            self.region_of_interest = [xmin, xmax, ymin, ymax]
        else:
            self.region_of_interest = None
        self.katrain.controls.set_status("", OUTPUT_INFO)

    # ---------------------------------------------------------------------------
    # analyze_extra() handler methods (Phase 70 refactoring)
    # ---------------------------------------------------------------------------

    def _handle_stop_mode(self) -> None:
        """Handle STOP mode: stop pondering and terminate queries on all engines."""
        self.katrain.pondering = False
        for e in set(self.engines.values()):
            e.stop_pondering()
            e.terminate_queries()

    def _handle_ponder_mode(self, cn: GameNode, engine: KataGoEngine) -> None:
        """Handle PONDER mode: start background pondering on current node."""
        cn.analyze(
            engine,
            ponder=True,
            priority=PRIORITY_EXTRA_ANALYSIS,
            region_of_interest=self.region_of_interest,
            time_limit=False,
        )

    def _handle_extra_mode(self, cn: GameNode, engine: KataGoEngine) -> None:
        """Handle EXTRA mode: add more visits to current node analysis."""
        visits = cn.analysis_visits_requested + engine.config["max_visits"]
        self.katrain.controls.set_status(i18n._("extra analysis").format(visits=visits), STATUS_ANALYSIS)
        cn.analyze(
            engine,
            visits=visits,
            priority=PRIORITY_EXTRA_ANALYSIS,
            region_of_interest=self.region_of_interest,
            time_limit=False,
        )

    def _handle_game_mode(self, engine: KataGoEngine, **kwargs: Any) -> None:
        """Handle GAME mode: re-analyze all nodes in the game tree."""
        nodes = [n for n in self.root.nodes_in_tree if isinstance(n, GameNode)]
        only_mistakes = kwargs.get("mistakes_only", False)
        move_range: tuple[int, int] | None = kwargs.get("move_range")
        if move_range and move_range[1] < move_range[0]:
            move_range = (move_range[1], move_range[0])  # Swap to ensure correct order
        threshold = self.katrain.config("trainer/eval_thresholds")[-4]
        if "visits" in kwargs:
            visits = kwargs["visits"]
        else:
            min_visits = min(node.analysis_visits_requested for node in nodes)
            visits = min_visits + engine.config["max_visits"]
        for node in nodes:
            max_point_loss = max(
                c.points_lost or 0 for c in [node] + [ch for ch in node.children if isinstance(ch, GameNode)]
            )
            if only_mistakes and max_point_loss <= threshold:
                continue
            if move_range and (node.depth - 1 not in range(move_range[0], move_range[1] + 1)):
                continue
            node.analyze(engine, visits=visits, priority=-1_000_000, time_limit=False)
        if not move_range:
            self.katrain.controls.set_status(i18n._("game re-analysis").format(visits=visits), STATUS_ANALYSIS)
        else:
            self.katrain.controls.set_status(
                i18n._("move range analysis").format(start_move=move_range[0], end_move=move_range[1], visits=visits),
                STATUS_ANALYSIS,
            )

    def _handle_sweep_equalize_modes(
        self,
        cn: GameNode,
        engine: KataGoEngine,
        mode: AnalysisMode,
        stones: set[tuple[int, int] | None],
    ) -> None:
        """Handle SWEEP, EQUALIZE, ALTERNATIVE, and LOCAL modes.

        These modes share a common refinement loop at the end.
        """
        analyze_moves: list[Move]
        visits: int
        priority: int

        if mode == AnalysisMode.SWEEP:
            board_size_x, board_size_y = self.board_size

            if cn.analysis_exists:
                policy_grid: list[list[float | None]] | None = (
                    var_to_grid(self.current_node.policy, size=(board_size_x, board_size_y))
                    if self.current_node.policy
                    else None
                )
                if policy_grid is not None:
                    # Sort by policy value when grid is available
                    moves_to_analyze: list[Move] = []
                    for x in range(board_size_x):
                        for y in range(board_size_y):
                            pval = policy_grid[y][x]
                            if pval is not None and pval >= 0:
                                moves_to_analyze.append(Move(coords=(x, y), player=cn.next_player))

                    def get_policy_key(mv: Move) -> float:
                        if mv.coords:
                            pval = policy_grid[mv.coords[1]][mv.coords[0]]
                            if pval is not None:
                                return -pval
                        return 0.0

                    analyze_moves = sorted(moves_to_analyze, key=get_policy_key)
                else:
                    # No policy grid - use all empty points
                    analyze_moves = [
                        Move(coords=(x, y), player=cn.next_player)
                        for x in range(board_size_x)
                        for y in range(board_size_y)
                        if (x, y) not in stones
                    ]
            else:
                analyze_moves = [
                    Move(coords=(x, y), player=cn.next_player)
                    for x in range(board_size_x)
                    for y in range(board_size_y)
                    if (x, y) not in stones
                ]
            visits = engine.config["fast_visits"]
            self.katrain.controls.set_status(i18n._("sweep analysis").format(visits=visits), STATUS_ANALYSIS)
            priority = PRIORITY_SWEEP

        elif mode in (AnalysisMode.EQUALIZE, AnalysisMode.ALTERNATIVE, AnalysisMode.LOCAL):
            if not cn.analysis_complete and mode != AnalysisMode.LOCAL:
                self.katrain.controls.set_status(i18n._("wait-before-extra-analysis"), STATUS_INFO, self.current_node)
                return
            if (
                mode == AnalysisMode.ALTERNATIVE
            ):  # also do a quick update on current candidates so it doesn't look too weird
                self.katrain.controls.set_status(i18n._("alternative analysis"), STATUS_ANALYSIS)
                cn.analyze(engine, priority=PRIORITY_ALTERNATIVES, time_limit=False, find_alternatives=True)
                visits = engine.config["fast_visits"]
            else:  # equalize or local
                visits = max(d["visits"] for d in cn.analysis["moves"].values())
                self.katrain.controls.set_status(i18n._("equalizing analysis").format(visits=visits), STATUS_ANALYSIS)
            priority = PRIORITY_EQUALIZE
            analyze_moves = [Move.from_gtp(gtp, player=cn.next_player) for gtp, _ in cn.analysis["moves"].items()]

        else:
            raise ValueError(f"Invalid analysis mode for sweep/equalize handler: {mode}")

        # Common refinement loop for SWEEP/EQUALIZE/ALTERNATIVE/LOCAL
        for move in analyze_moves:
            if cn.analysis["moves"].get(move.gtp(), {"visits": 0})["visits"] < visits:
                cn.analyze(
                    engine, priority=priority, visits=visits, refine_move=move, time_limit=False
                )  # explicitly requested so take as long as you need

    # ---------------------------------------------------------------------------
    # analyze_extra() main dispatcher (Phase 70 refactoring)
    # ---------------------------------------------------------------------------

    def analyze_extra(self, mode: str | AnalysisMode, **kwargs: Any) -> None:
        """Dispatch to appropriate handler based on analysis mode.

        Phase 70: Refactored from 119-line monolithic method to dispatcher + 5 handlers.
        """
        # Normalize mode to AnalysisMode at entry point
        parsed_mode = parse_analysis_mode(mode)

        stones = {s.coords for s in self.stones}
        cn = self.current_node

        if parsed_mode == AnalysisMode.STOP:
            self._handle_stop_mode()
            return

        engine = self.engines[cn.next_player]

        if parsed_mode == AnalysisMode.PONDER:
            self._handle_ponder_mode(cn, engine)
            return

        if parsed_mode == AnalysisMode.EXTRA:
            self._handle_extra_mode(cn, engine)
            return

        if parsed_mode == AnalysisMode.GAME:
            self._handle_game_mode(engine, **kwargs)
            return

        # SWEEP / EQUALIZE / ALTERNATIVE / LOCAL
        self._handle_sweep_equalize_modes(cn, engine, parsed_mode, stones)

    def selfplay(self, until_move: int | str, target_b_advantage: float | None = None) -> None:
        cn = self.current_node

        analysis_kwargs: dict[str, Any]
        engine_settings: dict[str, Any]
        if target_b_advantage is not None:
            analysis_kwargs = {"visits": max(25, self.katrain.config("engine/fast_visits"))}
            engine_settings = {"wideRootNoise": 0.03}
        else:
            analysis_kwargs = {}
            engine_settings = {}

        def set_analysis(node: GameNode, result: dict[str, Any]) -> None:
            node.set_analysis(result)
            analyze_and_play(node)

        def request_analysis_for_node(node: GameNode) -> None:
            self.engines[node.player].request_analysis(
                node,
                callback=lambda result, _partial: set_analysis(node, result),
                priority=PRIORITY_DEFAULT,
                analyze_fast=True,
                extra_settings=engine_settings,
                **analysis_kwargs,
            )

        def analyze_and_play(node: GameNode) -> None:
            nonlocal cn, engine_settings
            candidates = node.candidate_moves
            if self.katrain.game is not self:
                return  # a new game happened
            ai_thoughts = "Move generated by AI self-play\n"
            selected_move: Move
            if until_move != "end" and target_b_advantage is not None:  # setup pos
                assert isinstance(until_move, int)  # narrow type: not "end" means it's int
                if node.depth >= until_move or candidates[0]["move"] == "pass":
                    self.set_current_node(node)
                    return
                assert cn.score is not None and node.score is not None
                target_score = cn.score + (node.depth - cn.depth + 1) * (target_b_advantage - cn.score) / (
                    until_move - cn.depth
                )
                max_loss = 5
                stddev = min(3, 0.5 + (until_move - node.depth) * 0.15)
                ai_thoughts += f"Selecting moves aiming at score {target_score:.1f} +/- {stddev:.2f} with < {max_loss} points lost\n"
                if abs(node.score - target_score) < 3 * stddev:
                    weighted_cands = [
                        (
                            cand,
                            math.exp(-0.5 * (abs(cand["scoreLead"] - target_score) / stddev) ** 2)
                            * math.exp(-0.5 * (min(0, cand["pointsLost"]) / max_loss) ** 2),
                        )
                        for i, cand in enumerate(candidates)
                        if cand["pointsLost"] < max_loss or i == 0
                    ]
                    move_info = weighted_selection_without_replacement(weighted_cands, 1)[0][0]
                    for cand, wt in weighted_cands:
                        self.katrain.log(
                            f"{'* ' if move_info == cand else '  '} {cand['move']} {cand['scoreLead']} {wt}",
                            OUTPUT_EXTRA_DEBUG,
                        )
                        ai_thoughts += f"Move option: {cand['move']} score {cand['scoreLead']:.2f} loss {cand['pointsLost']:.2f} weight {wt:.3e}\n"
                else:  # we're a bit lost, far away from target, just push it closer
                    move_info = min(candidates, key=lambda m: abs(m["scoreLead"] - target_score))
                    self.katrain.log(
                        f"* Played {move_info['move']} {move_info['scoreLead']} because score deviation between current score {node.score} and target score {target_score} > {3 * stddev}",
                        OUTPUT_EXTRA_DEBUG,
                    )
                    ai_thoughts += f"Move played to close difference between score {node.score:.1f} and target {target_score:.1f} quickly."

                self.katrain.log(
                    f"Self-play until {until_move} target {target_b_advantage}: {len(candidates)} candidates -> move {move_info['move']} score {move_info['scoreLead']} point loss {move_info['pointsLost']}",
                    OUTPUT_DEBUG,
                )
                selected_move = Move.from_gtp(move_info["move"], player=node.next_player)
            elif candidates:  # just selfplay to end
                selected_move = Move.from_gtp(candidates[0]["move"], player=node.next_player)
            else:  # 1 visit etc
                polmoves = node.policy_ranking
                top_move = polmoves[0][1] if polmoves else None
                selected_move = top_move if top_move is not None else Move(None)
            if selected_move.is_pass:
                if self.current_node == cn:
                    self.set_current_node(node)
                return
            new_node = GameNode(parent=node, move=selected_move)
            new_node.ai_thoughts = ai_thoughts
            if until_move != "end" and target_b_advantage is not None:
                self.set_current_node(new_node)
                self.katrain.controls.set_status(
                    i18n._("setup game status message").format(move=new_node.depth, until_move=until_move),
                    STATUS_INFO,
                )
            else:
                if node != cn:
                    node.remove_shortcut()
                cn.add_shortcut(new_node)

            self.katrain.controls.move_tree.redraw_tree_trigger()
            request_analysis_for_node(new_node)

        request_analysis_for_node(cn)

    def analyze_undo(self, node: GameNode) -> None:
        train_config = self.katrain.config("trainer")
        move = node.move
        if node != self.current_node or node.auto_undo is not None or not node.analysis_complete or not move:
            return
        points_lost = node.points_lost
        thresholds = train_config["eval_thresholds"]
        num_undo_prompts = train_config["num_undo_prompts"]
        i = 0
        while i < len(thresholds) and points_lost is not None and points_lost < thresholds[i]:
            i += 1
        num_undos = num_undo_prompts[i] if i < len(num_undo_prompts) else 0
        undo: bool
        parent = node.parent
        if num_undos == 0:
            undo = False
        elif num_undos < 1:  # probability
            undo = bool(node.undo_threshold < num_undos) and parent is not None and len(parent.children) == 1
        else:
            undo = parent is not None and len(parent.children) <= num_undos

        node.auto_undo = undo
        if undo:
            self.undo(1)
            self.katrain.controls.set_status(
                i18n._("teaching undo message").format(move=move.gtp(), points_lost=points_lost), STATUS_TEACHING
            )
            self.katrain.update_state()
